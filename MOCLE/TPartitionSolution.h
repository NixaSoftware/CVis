// Class automatically generated by Dev-C++ New Class wizard

#ifndef TPARTITIONSOLUTION_H
#define TPARTITIONSOLUTION_H

#if !defined(AFX_TNEWSOLUTION_H__D5674F74_1B7C_11D5_8398_000000000000__INCLUDED_)
#define AFX_TNEWSOLUTION_H__D5674F74_1B7C_11D5_8398_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "MO/momhsolution.h" // inheriting class's header file

#include <iostream>
#include <cstdlib>
#include <set>
#include <vector>
#include <iterator>

// para incluir as bibliotecas Boost
/*#include <boost/filesystem/operations.hpp> // includes boost/filesystem/path.hpp
#include <boost/filesystem/fstream.hpp>    // ditto
#include <boost/filesystem/convenience.hpp>    // ditto
#include <boost/lexical_cast.hpp>
*/
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/tokenizer.hpp>


#include "cluster.h"
#include "tPatterns.h"
#include "tPartition.h"
#include "validationIndices.h"
#include "clusteringTypes.h"

namespace fs = boost::filesystem;



/*
 * No description
 */
class TPartitionSolution : public TMOMHSolution {
//protected:
public:
	// To do:	Define fields storing all the data of your solution
    
    tPartition *truePartition;
    tPartition solutionPartition;
    
    double purity(tPartition &Pe);
    double correctedRand(tPartition &Pe, tPartition &Pr);
    double informationGain(tPartition &Pe);
    double connectivity(tPartition &Pe);
    double deviation(tPartition &Pe);
    double deviationPearson(tPartition &Pe);
    double connectivityPearson(tPartition &Pe);
//   void loadPartition(); //(atualizar o valor de nPat )

public:
       
    //TPartitionSolution(fs::path partitionFileName, fs::path fileClasses);//:patterns(partitionFileName,fileClasses);
    TPartitionSolution();
    TPartitionSolution(TPartitionSolution &part);
    TPartitionSolution(fs::path partitionFileName, tPatterns *pat, tPartition *part);// part should be the true partition
    TPartitionSolution(TPartitionSolution &parent1, TPartitionSolution &parent2);

    void Mutate ();

        
private:
    //int countClass(string patternClass, std::vector<string> &clustersContents);
    void consensusEdge(TPartitionSolution &parent1, TPartitionSolution &parent2);
    void consensusDiff(TPartitionSolution &parent1, TPartitionSolution &parent2);
    void consensusBipartiteGraph(TPartitionSolution &parent1, TPartitionSolution &parent2);
    void consensusMCLA(TPartitionSolution &parent1, TPartitionSolution &parent2);
    void randomUnion(TPartitionSolution &parent1, TPartitionSolution &parent2);


//
//// @@@@ Step 7 (Optional)
//public:
//	TPartitionSolution (TPartitionSolution& SourceSolution);
//
//// @@@@ Step 8 (Optional)
//public:
//	virtual ostream& Save(ostream& Stream);
//
//// @@@@ Step 9.1.1
//public:
//	void LocalSearch (TPoint& ReferencePoint);
//	
//// @@@@ Step 9.1.2 
//public:
//	TPartitionSolution (TScalarizingFunctionType ScalarizingFunctionType, TPoint& ReferencePoint, TWeightVector WeightVector, TNondominatedSet &NondominatedSet);
//
//// @@@@ Step 9.1.3
//public:
//	TPartitionSolution::TPartitionSolution (TPartitionSolution& Parent1, TPartitionSolution& Parent2, TScalarizingFunctionType ScalarizingFunctionType, TPoint& ReferencePoint, TWeightVector WeightVector, TNondominatedSet &NondominatedSet);
//
//// @@@@ Step 9.2.1 and 9.3.1
//	TPartitionSolution ();
//
//// @@@@ Step 9.2.2
//	void FindLocalMove ();
//
//// @@@@ Step 9.2.3 (Optional)
//	void AcceptLocalMove ();
//
//// @@@@ Step 9.2.4 
//	void RejectLocalMove ();
//
//// @@@@ Step 9.3.2
//	TPartitionSolution::TPartitionSolution (TPartitionSolution& Parent1, TPartitionSolution& Parent2);
//
//// @@@@ Step 9.3.3 (Optional)
//	void Mutate ();
};

#endif // !defined(AFX_TNEWSOLUTION_H__D5674F74_1B7C_11D5_8398_000000000000__INCLUDED_)

#endif // TPARTITIONSOLUTION_H

