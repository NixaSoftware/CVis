// Class automatically generated by Dev-C++ New Class wizard

#include "TPartitionSolution.h" // class's header file


//TPartitionSolution::TPartitionSolution(fs::path partitionFileName, fs::path fileClasses) :
//    patterns(partitionFileName, fileClasses)
//{
//}

TPartitionSolution::TPartitionSolution()
{
    //std::cout << "entrei no TPartitionSolution SEM parametros" << std::endl;
    //getchar();
}



TPartitionSolution::TPartitionSolution(TPartitionSolution &part): 
    //TMOMHSolution(part), 
    truePartition(part.truePartition), 
    solutionPartition(part.solutionPartition)
{
    if (Objectives [nClusters_obj].bActive) 
        ObjectiveValues[nClusters_obj] = solutionPartition.nClusters();
    if (Objectives [informationGain_obj].bActive) 
        ObjectiveValues[informationGain_obj] = informationGain(solutionPartition);
    if (Objectives [connectivity_obj].bActive) 
        ObjectiveValues[connectivity_obj] = connectivity(solutionPartition);
    if (Objectives [correctedRand_obj].bActive) 
        ObjectiveValues[correctedRand_obj] = correctedRand(solutionPartition, *truePartition);
    if (Objectives [purity_obj].bActive) 
        ObjectiveValues[purity_obj] = purity(solutionPartition);
    if (Objectives [deviation_obj].bActive) 
        ObjectiveValues[deviation_obj] = deviation(solutionPartition);
    if (Objectives [deviationPearson_obj].bActive) 
        ObjectiveValues[deviationPearson_obj] = deviationPearson(solutionPartition);
    if (Objectives [connectivityPearson_obj].bActive) 
        ObjectiveValues[connectivityPearson_obj] = connectivityPearson(solutionPartition);
}


// part is the true partition
TPartitionSolution::TPartitionSolution(fs::path partitionFileName, tPatterns *pat, tPartition *part) : 
    truePartition(part), solutionPartition(pat->dataset, partitionFileName, pat)
{
//    std::cout << "entrei no TPartitionSolution COM parametros" << std::endl;
//    getchar();

//    std::cout << "teste - carreguei variaveis dp tPartitionSolution" << std::endl;

    if (Objectives [nClusters_obj].bActive) 
        ObjectiveValues[nClusters_obj] = solutionPartition.nClusters();
    if (Objectives [informationGain_obj].bActive) 
        ObjectiveValues[informationGain_obj] = informationGain(solutionPartition);
    if (Objectives [connectivity_obj].bActive) 
        ObjectiveValues[connectivity_obj] = connectivity(solutionPartition);
    if (Objectives [correctedRand_obj].bActive) 
        ObjectiveValues[correctedRand_obj] = correctedRand(solutionPartition, *truePartition);
    if (Objectives [purity_obj].bActive) 
        ObjectiveValues[purity_obj] = purity(solutionPartition);
    if (Objectives [deviation_obj].bActive) 
        ObjectiveValues[deviation_obj] = deviation(solutionPartition);
    if (Objectives [deviationPearson_obj].bActive) 
        ObjectiveValues[deviationPearson_obj] = deviationPearson(solutionPartition);
    if (Objectives [connectivityPearson_obj].bActive) 
        ObjectiveValues[connectivityPearson_obj] = connectivityPearson(solutionPartition);
}





TPartitionSolution::TPartitionSolution(TPartitionSolution &parent1, TPartitionSolution &parent2): 
    //TMOMHSolution(parent1, parent2), 
    truePartition(parent1.truePartition), 
    solutionPartition(parent1.truePartition->patterns)
{
// crossover: pode-se escolher entre o meu e o edge-based
   
//    edge(parent1, parent2);
//    diff(parent1, parent2);
//    randomUnion(parent1, parent2);

    switch (crossoverType)
    {
        case bipartite:
        {        
            consensusBipartiteGraph(parent1, parent2);   
            break;
        }    
        case mcla:
        {        
            consensusMCLA(parent1, parent2);   
            break;
        }  
        case diff:
        {
            consensusDiff(parent1, parent2);
            break;
        }    
        case edge:
        {
            consensusEdge(parent1, parent2);
            break;
        }    
    }      

    solutionPartition.calculateCentroids();
    
    if (Objectives [nClusters_obj].bActive) 
        ObjectiveValues[nClusters_obj] = solutionPartition.nClusters();
    if (Objectives [informationGain_obj].bActive) 
        ObjectiveValues[informationGain_obj] = informationGain(solutionPartition);
    if (Objectives [connectivity_obj].bActive) 
        ObjectiveValues[connectivity_obj] = connectivity(solutionPartition);
    if (Objectives [correctedRand_obj].bActive) 
        ObjectiveValues[correctedRand_obj] = correctedRand(solutionPartition, *truePartition);
    if (Objectives [purity_obj].bActive) 
        ObjectiveValues[purity_obj] = purity(solutionPartition);
    if (Objectives [deviation_obj].bActive) 
        ObjectiveValues[deviation_obj] = deviation(solutionPartition);
    if (Objectives [deviationPearson_obj].bActive) 
        ObjectiveValues[deviationPearson_obj] = deviationPearson(solutionPartition);
    if (Objectives [connectivityPearson_obj].bActive) 
        ObjectiveValues[connectivityPearson_obj] = connectivityPearson(solutionPartition);
}

// edge-based crossover, Jones-1991, tambem descrito na tese de Cole-1998
void TPartitionSolution::consensusEdge(TPartitionSolution &parent1, TPartitionSolution &parent2) 
{   
    
    set <int>::iterator it1;
    tPartition::tClustersIt clusterIt1, clusterIt2;

    std::vector <set<int> > intersections;
    set <int> intersection;
    insert_iterator<set<int> > itIntersection(intersection, intersection.begin());
    
    // acha as interseccoes nao vazias dos clusters dos dois pais
    for (clusterIt1 = parent1.solutionPartition.clusters.begin();
         clusterIt1 != parent1.solutionPartition.clusters.end();
         clusterIt1++)
    {
        for (clusterIt2 = parent2.solutionPartition.clusters.begin();
             clusterIt2 != parent2.solutionPartition.clusters.end();
             clusterIt2++)
        {
//            std::cout << std::endl << "cluster part 1 : ";
//            for (set <int>::iterator it1 = (*parent1.solutionPartition.clustersIt).patterns.begin(); 
//                 it1 != (*parent1.solutionPartition.clustersIt).patterns.end(); 
//                 it1++)
//            {
//                std::cout << (*it1) << " ";
//            }
//            std::cout << std::endl << "cluster part 2 : ";
//            for (set <int>::iterator it2 = (*parent2.solutionPartition.clustersIt).patterns.begin(); 
//                 it2 != (*parent2.solutionPartition.clustersIt).patterns.end(); 
//                 it2++)
//            {
//                std::cout << (*it2) << " ";
//            }
//            std::cout << std::endl;
            set_intersection((*clusterIt1).patterns.begin(), 
                             (*clusterIt1).patterns.end(),
                             (*clusterIt2).patterns.begin(), 
                             (*clusterIt2).patterns.end(),
                             itIntersection);
            if (!intersection.empty())
                intersections.insert(intersections.end(), intersection);
            intersection.clear();
        }
    }
    

    // choose the number of clusters of the child
    int nClustersParent1 = parent1.solutionPartition.nClusters();
    int nClustersParent2 = parent2.solutionPartition.nClusters();
    // the child will have the number of clusters randomly choosen between the number or
    // clusters of the parents
    int nClustersChild;
    // apenas para testar os tipos de recombinacao, escolho numero de clusters como o do pai com menos clusters                          
    if (nClustersParent1 <= nClustersParent2)
        nClustersChild =  nClustersParent1; // randomInt(nClustersParent1, nClustersParent2);
    else nClustersChild = nClustersParent2; // randomInt(nClustersParent2, nClustersParent1);
    
//    std::cout << std::endl << "pai1: " << nClustersParent1 << " - pai2: " << nClustersParent2 << " - nClustersChild: " << nClustersChild << std::endl;

    int iter = 1;
    // join pairs of groups until the number of clusters of the child
    // be achieved
    int nClusters = intersections.size();
    while (nClusters > nClustersChild)
    {
        iter++;
        std::vector< set<int> > possibleClusters;
        std::vector<int> nNonInherited;
        std::vector<pair<int, int> > clustersOfOrigin;
        
        for (std::vector <set<int> >::iterator itC1 = intersections.begin();
             itC1 != intersections.end();
             itC1++)
        {
            for (std::vector <set<int> >::iterator itC2 = itC1+1;
                 itC2 != intersections.end();
                 itC2++)
            {
                std::set<int>::iterator itP1, itP2;
                int nNI = 0;
                for (std::set<int>::iterator it1 = (*itC1).begin(); it1 != (*itC1).end(); it1++)
                {
                    for (std::set<int>::iterator it2 = (*itC2).begin(); it2 != (*itC2).end(); it2++)
                    {
                        //std::cout << " edge: " << (*it1) << "-" << (*it2);
                        bool nonInherited = true;
                        // procura a aresta it1 - it2 nos clusters do pai 1
                        for (clusterIt1 = parent1.solutionPartition.clusters.begin();
                             clusterIt1 != parent1.solutionPartition.clusters.end();
                             clusterIt1++)
                        {
                             itP1 = (*clusterIt1).patterns.find((*it1));
                             itP2 = (*clusterIt1).patterns.find((*it2));
                             if ((itP1 != (*clusterIt1).patterns.end()) &&
                                 (itP2 != (*clusterIt1).patterns.end())) 
                             {
                                 nonInherited = false;
                             }
                        }
                        if (nonInherited)
                        {
                           // procura a aresta it1 - it2 nos clusters do pai 2
                           for (clusterIt2 = parent2.solutionPartition.clusters.begin();
                                clusterIt2 != parent2.solutionPartition.clusters.end();
                                clusterIt2++)
                           {
                               itP1 = (*clusterIt2).patterns.find((*it1));
                               itP2 = (*clusterIt2).patterns.find((*it2));
                               if ((itP1 != (*clusterIt2).patterns.end()) &&
                                   (itP2 != (*clusterIt2).patterns.end())) 
                               {
                                   nonInherited = false;
                               }
                           }
                        }
                        if (nonInherited) nNI++;
                    }
                }    
                nNonInherited.insert(nNonInherited.end(), nNI);               
                 
                set<int> newCluster;
                insert_iterator<set<int> > itNewCluster(newCluster, newCluster.begin());
                set_union((*itC1).begin(), (*itC1).end(), (*itC2).begin(), (*itC2).end(), itNewCluster);
                possibleClusters.insert(possibleClusters.end(), newCluster);
                int d1 = distance(intersections.begin(), itC1);
                int d2 = distance(intersections.begin(), itC2);
                clustersOfOrigin.insert(clustersOfOrigin.end(), make_pair(d1, d2));
           }             
        }
            
        // acha todos os clusters da interseccao que tem o menor numero de arestas nao herdadas
        vector<int>::const_iterator itMin = min_element(nNonInherited.begin(), nNonInherited.end());
                
        vector<int> positionsMin;
        for (int i = 0; i < nNonInherited.size(); i++)
        {
             if (nNonInherited[i] == (*itMin))
             {   
                 // guarda as posicoes no vetor de clusters possiveis onde estao
                 // localizados os clusters com a menor numero de arestas nao herdadas
                 positionsMin.insert(positionsMin.end(), i);
                 
//                 std::cout << "cluster " << i << ": ";
//                 for (std::set<int>::iterator it = possibleClusters[i].begin(); it != possibleClusters[i].end(); it++)
//                     std::cout << (*it) << " ";
//                 std::cout << std::endl;    
             }
        } 
        
        // sorteia um dos cluster com menor numero de arestas nao herdadas para ser o cluster resultante
        int pos = randomInt(0, positionsMin.size()-1);
        int c = positionsMin[0]; //positionsMin[pos]; SO PARA COMPARAR OPERADORES ESCOLHO O PRIMEIRO CASO
        
        int c1 = clustersOfOrigin[c].first;
        int c2 = clustersOfOrigin[c].second;
        
        // apaga os dois grupos que foram unidos e insere o novo grupo maior
        std::vector <set<int> >::iterator itC1;
        itC1 = intersections.begin();
        advance(itC1, c1);
        std::vector <set<int> >::iterator itC2;
        itC2 = intersections.begin();
        advance(itC2, c2);    
        // inserting or deleting an element in the middle of a vector invalidates 
        // all iterators that point to elements following the insertion or deletion point.            
        if (c1 < c2)
        {
            intersections.erase(itC2);
            intersections.erase(itC1);            
        }        
        else
        {
            intersections.erase(itC1);
            intersections.erase(itC2);            
        }        
        intersections.insert(intersections.end(), possibleClusters[c]);
        nClusters--;

//        std::cout << "Novo cluster " << c << ": ";       
//        for (std::set<int>::iterator it = possibleClusters[c].begin(); it != possibleClusters[c].end(); it++)
//            std::cout << (*it) << " ";
//        std::cout << std::endl;    
//
    }

    // Put the final result in the proper structure in solutionPartition (child)
    for (int i = 0; i < intersections.size(); i++)
    {
        cCluster myCluster;
        myCluster.clusterLabel = i + 1;
        myCluster.patterns = intersections[i];
        solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
    }
}

// meu, diff
void TPartitionSolution::consensusDiff(TPartitionSolution &parent1, TPartitionSolution &parent2)
{
    // meu crossover, descrito na tese
    
    set <int>::iterator it1;
    tPartition::tClustersIt clusterIt1, clusterIt2;
        
    std::vector <set<int> > intersections;
    set <int> intersection;
    insert_iterator<set<int> > itIntersection(intersection, intersection.begin());
    
    
//    std::cout << "entrei na recombinacao" << std::endl;
//    getchar();
    
    // acha as interseccoes nao vazias dos clusters dos dois pais
    for (clusterIt1 = parent1.solutionPartition.clusters.begin();
         clusterIt1 != parent1.solutionPartition.clusters.end();
         clusterIt1++)
    {
        for (clusterIt2 = parent2.solutionPartition.clusters.begin();
             clusterIt2 != parent2.solutionPartition.clusters.end();
             clusterIt2++)
        {
//            std::cout << std::endl << "cluster part 1 : ";
//            for (set <int>::iterator it1 = (*parent1.solutionPartition.clustersIt).patterns.begin(); 
//                 it1 != (*parent1.solutionPartition.clustersIt).patterns.end(); 
//                 it1++)
//            {
//                std::cout << (*it1) << " ";
//            }
//            std::cout << std::endl << "cluster part 2 : ";
//            for (set <int>::iterator it2 = (*parent2.solutionPartition.clustersIt).patterns.begin(); 
//                 it2 != (*parent2.solutionPartition.clustersIt).patterns.end(); 
//                 it2++)
//            {
//                std::cout << (*it2) << " ";
//            }
//            std::cout << std::endl;
            set_intersection((*clusterIt1).patterns.begin(), 
                             (*clusterIt1).patterns.end(),
                             (*clusterIt2).patterns.begin(), 
                             (*clusterIt2).patterns.end(),
                             itIntersection);
            if (!intersection.empty())
                intersections.insert(intersections.end(), intersection);
            intersection.clear();
        }
    }
    
    // choose the number of clusters of the child
    int nClustersParent1 = parent1.solutionPartition.nClusters();
    int nClustersParent2 = parent2.solutionPartition.nClusters();
    // the child will have the number of clusters randomly choosen between the number or
    // clusters of the parents
    int nClustersChild;
    // apenas para testar os tipos de recombinacao, escolho numero de clusters como o do pai com menos clusters                          
    if (nClustersParent1 <= nClustersParent2)
        nClustersChild =  nClustersParent1; // randomInt(nClustersParent1, nClustersParent2);
    else nClustersChild = nClustersParent2; // randomInt(nClustersParent2, nClustersParent1);
    
//    std::cout << std::endl << "pai1: " << nClustersParent1 << " - pai2: " << nClustersParent2 << " - nClustersChild: " << nClustersChild << std::endl;

//    int iter = 1;
    // join pairs of groups until the number of clusters of the child
    // be achieved
    int nClusters = intersections.size();
    while (nClusters > nClustersChild)
    {
//        iter++;
        std::vector< set<int> > possibleClusters;
        std::vector<int> differenceSize;
        std::vector<pair<int, int> > clustersOfOrigin;
        
        for (std::vector <set<int> >::iterator itC1 = intersections.begin();
             itC1 != intersections.end();
             itC1++)
        {
            for (std::vector <set<int> >::iterator itC2 = itC1+1;
                 itC2 != intersections.end();
                 itC2++)
            {                
                set<int> newCluster;
                insert_iterator<set<int> > itNewCluster(newCluster, newCluster.begin());
                set_union((*itC1).begin(), (*itC1).end(), (*itC2).begin(), (*itC2).end(), itNewCluster);
                possibleClusters.insert(possibleClusters.end(), newCluster);
                int d1 = distance(intersections.begin(), itC1);
                int d2 = distance(intersections.begin(), itC2);
                clustersOfOrigin.insert(clustersOfOrigin.end(), make_pair(d1, d2));

                // acha o valor m�nimo, entre todos os clusters de ambos os pais, do n�mero
                // de inst�ncias que est�o presentes no cluster (newCluster) do filho e n�o
                // est�o no cluster do pai.
                int diff = truePartition->nPatterns();
                int diffAux;
                
//                std::cout  << std::endl << "Diferencas: " << std::endl;   
                
                for (clusterIt1 = parent1.solutionPartition.clusters.begin();
                     clusterIt1 != parent1.solutionPartition.clusters.end();
                     clusterIt1++)
                {
                    set<int> clusterDifference;
                    insert_iterator<set<int> > itClusterDifference(clusterDifference, clusterDifference.begin());
                    set_difference(newCluster.begin(), 
                                   newCluster.end(),
                                   (*clusterIt1).patterns.begin(), 
                                   (*clusterIt1).patterns.end(),
                                   itClusterDifference);
                    diffAux = clusterDifference.size();
                    if (diffAux < diff) diff = diffAux;
                
//                    std::cout << "Cluster do pai: ";
//                    for (std::set<int>::iterator it = (*clusterIt1).patterns.begin(); it != (*clusterIt1).patterns.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl;    
//
//                    std::cout << "Dif: ";
//                    for (std::set<int>::iterator it = clusterDifference.begin(); it != clusterDifference.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl << "tamanho da diferenca: " << diffAux << std::endl;;                      
                                        
                }

                for (clusterIt1 = parent2.solutionPartition.clusters.begin();
                     clusterIt1 != parent2.solutionPartition.clusters.end();
                     clusterIt1++)
                {
                    set<int> clusterDifference;
                    insert_iterator<set<int> > itClusterDifference(clusterDifference, clusterDifference.begin());
                    set_difference(newCluster.begin(), 
                                   newCluster.end(),
                                   (*clusterIt1).patterns.begin(), 
                                   (*clusterIt1).patterns.end(),
                                   itClusterDifference);
                    diffAux = clusterDifference.size();
                    if (diffAux < diff) diff = diffAux;
                
//                    std::cout << "Cluster do pai: ";
//                    for (std::set<int>::iterator it = (*clusterIt1).patterns.begin(); it != (*clusterIt1).patterns.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl;    
//
//                    std::cout << "Dif: ";
//                    for (std::set<int>::iterator it = clusterDifference.begin(); it != clusterDifference.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl << "tamanho da diferenca: " << diffAux << std::endl;                     
                                        
                }
                differenceSize.insert(differenceSize.end(), diff);
            }
             
        }
            
        // acha todos os clusters da interseccao que tem o menor valor da diferenca calculada acima
        vector<int>::const_iterator itMin = min_element(differenceSize.begin(), differenceSize.end());
        
//        std::cout << "Menor valor entre todas as diferencas: " << (*itMin) << std::endl;
//        std::cout << "Possiveis clusters: " << std::endl;
         
        vector<int> positionsMin;
        for (int i = 0; i < differenceSize.size(); i++)
        {
             if (differenceSize[i] == (*itMin))
             {   
                 // guarda as posicoes no vetor de clusters possiveis onde estao
                 // localizados os clusters com a menor diferenca
                 positionsMin.insert(positionsMin.end(), i);
                 
//                 std::cout << "cluster " << i << ": ";
//                 for (std::set<int>::iterator it = possibleClusters[i].begin(); it != possibleClusters[i].end(); it++)
//                     std::cout << (*it) << " ";
//                 std::cout << std::endl;    
             }
        } 
        
        // sorteia um dos cluster com menor valor da diferenca para ser o cluster resultante
        int pos = randomInt(0, positionsMin.size()-1);
        int c = positionsMin[0]; //positionsMin[pos]; SO PARA COMPARAR OPERADORES ESCOLHO O PRIMEIRO CASO
        
        int c1 = clustersOfOrigin[c].first;
        int c2 = clustersOfOrigin[c].second;
        
        // apaga os dois grupos que foram unidos e insere o novo grupo maior
        std::vector <set<int> >::iterator itC1;
        itC1 = intersections.begin();
        advance(itC1, c1);
        std::vector <set<int> >::iterator itC2;
        itC2 = intersections.begin();
        advance(itC2, c2);    
        // inserting or deleting an element in the middle of a vector invalidates 
        // all iterators that point to elements following the insertion or deletion point.            
        if (c1 < c2)
        {
            intersections.erase(itC2);
            intersections.erase(itC1);            
        }        
        else
        {
            intersections.erase(itC1);
            intersections.erase(itC2);            
        }        
        intersections.insert(intersections.end(), possibleClusters[c]);
        nClusters--;

//        std::cout << "Novo cluster " << c << ": ";       
//        for (std::set<int>::iterator it = possibleClusters[c].begin(); it != possibleClusters[c].end(); it++)
//            std::cout << (*it) << " ";
//        std::cout << std::endl;    
    }

    // Put the final result in the proper structure in solutionPartition (child)
    for (int i = 0; i < intersections.size(); i++)
    {
        cCluster myCluster;
        myCluster.clusterLabel = i + 1;
        myCluster.patterns = intersections[i];
        solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
    }
}


// crossover by finding the consensus between the parent partitions using
// bipartite graph partitioning described in 
// "solving cluster ensemble problems by bipartite graph partitioning
// Fern and Brodley, in proceedings of the 21st International Conference
// on Machine Learning, 2004"
void TPartitionSolution::consensusBipartiteGraph(TPartitionSolution &parent1, TPartitionSolution &parent2) 
{
    fs::path graphDir;
    string graphDirName = basename(parent1.solutionPartition.dataset);
//    if (expType == semisupervised)
//        graphDirName += "SemiSupervised";        
//    else
//        if (expType == semisupervised2)
//            graphDirName += "SemiSupervised2";        
//        else
//            graphDirName += "Unsupervised";
//
//    switch (crossoverType)
//    {
//        case bipartite:
//        {        
//            graphDirName += "bipartite";   
//            break;
//        }    
//        case mcla:
//        {        
//            graphDirName += "mcla";  
//            break;
//        }  
//    } 

    graphDirName += "_" + ga;
    switch (crossoverType)
    {
        case bipartite:
        {        
            graphDirName += "_bipartite";   
            break;
        }    
        case mcla:
        {        
            graphDirName +=  "_mcla";  
            break;
        }  
        case diff:
        {        
            graphDirName +=  "_diff";  
            break;
        }  
        case edge:
        {        
            graphDirName +=  "_edge";  
            break;
        }  
    }      

    for (std::vector<t_objectives>::iterator objIt = objType.begin(); objIt != objType.end(); objIt++)
    {
        graphDirName += strObjectives(*objIt);
    } 
    
    graphDir = graphDirName;
    
    if (!exists(graphDir))
        fs::create_directory(graphDir);

    // construct the bipartite graph
    fs::path graphName = graphDir / "graph.txt";
    fs::ofstream graph;

    graph.open(graphName);
    if (!graph.good()) 
    {
        std::cout << "\nError in the file '" << graphName.string() << "'\n";
        getchar();
        exit(-1);
    } 
    
    //std::cout << "creating bipartite graph" << std::endl;
    
//    std::cout << "Partition: ";
//    parent1.solutionPartition.showPartition();
    
    int nVertices = parent1.solutionPartition.nPatterns() +
                    parent1.solutionPartition.nClusters() +
                    parent2.solutionPartition.nClusters();
    //parent1.solutionPartition.showPartition();
    //parent2.solutionPartition.showPartition();
    
//    std::cout << parent1.solutionPartition.nPatterns() << std::endl;
//    std::cout << parent1.solutionPartition.nClusters() << std::endl;
//    std::cout << parent2.solutionPartition.nClusters() << std::endl;
//    std::cout << nVertices << std::endl;

    // count the number of edges of the bipartite graph (the number of edges
    // is equal the sum of the number of patterns of each cluster in the ensemble)
    int nEdges = 0;    
    
    std::map<int, vector<int> > vertices;
    int cluster = parent1.solutionPartition.nPatterns() + 1;
    //std::cout << cluster << std::endl;

    for (tPartition::tClustersIt it = parent1.solutionPartition.clusters.begin();
         it != parent1.solutionPartition.clusters.end(); it++)
    {
        for (cCluster::tPatternsIt itP = (*it).patterns.begin(); 
             itP != (*it).patterns.end(); itP++)
        {
//            std::cout << "cluster: " << cluster << " - pattern: " << (*itP) << std::endl;
            vertices[cluster].insert(vertices[cluster].end(), (*itP));            
            vertices[(*itP)].insert(vertices[(*itP)].end(), cluster);
        }    
        nEdges += (*it).nPatterns();
        cluster++;
    }    
    for (tPartition::tClustersIt it = parent2.solutionPartition.clusters.begin();
         it != parent2.solutionPartition.clusters.end(); it++)
    {
        for (cCluster::tPatternsIt itP = (*it).patterns.begin(); 
             itP != (*it).patterns.end(); itP++)
        {
//            std::cout << "cluster: " << cluster << " - pattern: " << (*itP) << std::endl;
            vertices[cluster].insert(vertices[cluster].end(), (*itP));            
            vertices[(*itP)].insert(vertices[(*itP)].end(), cluster);
        }    
        nEdges += (*it).nPatterns();
        cluster++;
    }    
        
    graph << nVertices << "\t" << nEdges << std::endl;
    for (std::map<int, vector<int> >::iterator itV = vertices.begin();
         itV != vertices.end(); itV++)
    {
        //std::cout << (*itV).first << "\t"; 
        for (int e = 0; e < (*itV).second.size(); e++)
        {
            graph << (*itV).second[e] << "\t";
            //std::cout << (*itV).second[e] << "\t";
        }    
        graph << std::endl;
        //std::cout << std::endl;
    }                
    
    graph.close();

    //std::cout << "graph constructed" << std::endl;

    // chose the number of clusters of the child    
    // the child will have the number of clusters randomly choosen between the number or
    // clusters of the parents
    int nClustersParent1 = parent1.solutionPartition.nClusters();
    int nClustersParent2 = parent2.solutionPartition.nClusters();
    int nClustersChild;
    if (nClustersParent1 <= nClustersParent2)
        nClustersChild = randomInt(nClustersParent1, nClustersParent2);
    else nClustersChild = randomInt(nClustersParent2, nClustersParent1);

    string command;
    switch (runningSystem)
    {
        case mylinux:
        {           
            command = "gpmetis -dbglvl=0 " + graphName.string() + " " +
                      boost::lexical_cast<string>(nClustersChild);
            break;
        }    
        case mywindows:
        {           
            command = "gpmetis " + graphName.string() + " " +
                      boost::lexical_cast<string>(nClustersChild);
            break;
        }    
    }    

    system(command.c_str());

    fs::path resultName;
    fs::ifstream res;

    resultName = graphName.string() + ".part." + boost::lexical_cast<string>(nClustersChild);
    //std::cout << resultName.string() << std::endl;
    res.open(resultName);
    if (!res.good()) 
    {
        std::cout << "\nError in the file '" << resultName.string() << "'\n";
        getchar();
        exit(-1);
    }    

    int clu;
    for (int id = firstPatternNumber; id <= parent1.solutionPartition.nPatterns(); id++)
    //while (!res.eof())
    {
        res >> clu;
        clu += 1; // para os rotulos dos clusters serem >= 1, porque no arquivo comeca em 0
//        std::cout << "id: " << id << " cluster: " << clu << std::endl;
        if (!res.fail())
        {           

            tPartition::tClustersIt clustersIt = solutionPartition.clusters.begin();
            bool found = false;
            while (!found && (clustersIt != solutionPartition.clusters.end())) 
            {
                if ((*clustersIt).clusterLabel == clu) found = true;
                else clustersIt++;
            }    

           if (found)
           {
               (*clustersIt).insertPattern(id);                                          
           }
           else
           {
               cCluster myCluster;
               myCluster.clusterLabel = clu;
               myCluster.insertPattern(id);
               solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
           }
        }
    }
    res.close();
    remove_all(graphDir);
     
//    std::cout << "result: " << std::endl;
//    for (tPartition::tClustersIt clustersIt = solutionPartition.clusters.begin(); 
//         clustersIt != solutionPartition.clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }
//    getchar();
}






// crossover by finding the consensus between the parent partitions using
// MCLA described in  
//Strehl, A. and Ghosh, J.: 
//Cluster ensembles - a knowledge reuse framework for combining partitions. 
//Journal of Machine Learning Research, 3 (2002) 583-617                                
void TPartitionSolution::consensusMCLA(TPartitionSolution &parent1, TPartitionSolution &parent2) 
{
    passo++;
    
    fs::path graphDir;
    string graphDirName = basename(parent1.solutionPartition.dataset);

    graphDirName += "_" + ga;
    switch (crossoverType)
    {
        case bipartite:
        {        
            graphDirName += "_bipartite";   
            break;
        }    
        case mcla:
        {        
            graphDirName +=  "_mcla";  
            break;
        }  
        case diff:
        {        
            graphDirName +=  "_diff";  
            break;
        }  
        case edge:
        {        
            graphDirName +=  "_edge";  
            break;
        }  
    }      

    for (std::vector<t_objectives>::iterator objIt = objType.begin(); objIt != objType.end(); objIt++)
    {
        graphDirName += strObjectives(*objIt);
    } 
    
    graphDir = graphDirName;

    if (!exists(graphDir))
        fs::create_directory(graphDir);

    // construct the meta-graph
    std::string gr = boost::lexical_cast<string>(passo) + "graph.txt";
    fs::path graphName = graphDir / gr;
    fs::ofstream graph;

    graph.open(graphName);
    if (!graph.good()) 
    {
        std::cout << "\nError in the file '" << graphName.string() << "'\n";
        getchar();
        exit(-1);
    } 
    
    
//    fs::path xpai1 = boost::lexical_cast<string>(passo) + "pai1.txt";
//    fs::path xpai2 = boost::lexical_cast<string>(passo) + "pai2.txt";
//
//    fs::path pai1 = graphDir / xpai1;
//    fs::path pai2 = graphDir / xpai2;
//    parent1.solutionPartition.savePartition(pai1);
//    parent2.solutionPartition.savePartition(pai2);
    
    int kP1 = parent1.solutionPartition.nClusters();
    int kP2 = parent2.solutionPartition.nClusters();
         
    int nVertices = kP1 + kP2;
    
//    std::cout << "Pai 1:" << std::endl << std::endl;
//    parent1.solutionPartition.showPartition();
//    std::cout<< std::endl << std::endl << "Pai 2:" << std::endl << std::endl;
//    parent2.solutionPartition.showPartition();
 
    // there are edges among the clusters of the two partitions
    int nEdges = kP1 * kP2;    
    
    map <int, map<int, int> > h; // int -> indice do h, int -> objeto,  int -> 0 ou 1 se objeto nao pertence ou pertence ao cluster hi
    
    int indH = 1;
    int begin_hP1 = indH; 
    
    for (indH = begin_hP1; indH <= nVertices; indH++)
    {
        for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
             patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
        {
            h[indH][(*patternsIt).patternNumber] = 0;       
        }
    }    
        
    indH = begin_hP1;        
    for (tPartition::tClustersIt c = parent1.solutionPartition.clusters.begin();
         c != parent1.solutionPartition.clusters.end(); c++)
    {           
        for (cCluster::tPatternsIt it = (*c).patterns.begin(); it != (*c).patterns.end(); it++)
        {
            h[indH][(*it)] = 1;
        }    
        indH++;
    }
    int end_hP1 = indH - 1;
    int begin_hP2 = indH;
    for (tPartition::tClustersIt c = parent2.solutionPartition.clusters.begin();
         c != parent2.solutionPartition.clusters.end(); c++)
    {           
        for (cCluster::tPatternsIt it = (*c).patterns.begin(); it != (*c).patterns.end(); it++)
        {
            h[indH][(*it)] = 1;
        }    
        indH++;
    }
    int end_hP2 = indH - 1;
    
       
//    std::cout << "object\t";
//    for (int i = begin_hP1; i <= end_hP2; i++)
//        std::cout << "h " << i << "\t";
//    std::cout << std::endl;
//    for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
//         patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
//    {
//        std::cout << (*patternsIt).patternNumber << "\t";
//        for (int i = begin_hP1; i <= end_hP2; i++)
//            std::cout << h[i][(*patternsIt).patternNumber] << "\t";
//        std::cout << std::endl;
//    }    


//    std::string resName = boost::lexical_cast<string>(passo) + "resumo.txt";
//    fs::path resumoName = graphDir / resName;
//    fs::ofstream resumo;
//
//    resumo.open(resumoName);
//    if (!resumo.good()) 
//    {
//        std::cout << "\nError in the file '" << resumoName.string() << "'\n";
//        getchar();
//        exit(-1);
//    } 


    std::map<int, std::map<int, double> > w; // pesos das arestas
    int size1, size2, sizeInter;
    
    nEdges = 0;
    for (int i = begin_hP1; i <= end_hP1; i++)
    {
        size1 = 0;
        for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
             patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
            if (h[i][(*patternsIt).patternNumber] == 1) size1++;                         
        
        for (int j = begin_hP2; j <= end_hP2; j++)
        {
            //resumo << "i: " << i << "\tj: " << j << "\t";
            
            size2 = 0;
            sizeInter = 0; 
            for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
                 patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
            {
                if (h[j][(*patternsIt).patternNumber] == 1) 
                {
                    size2++;
                    if (h[i][(*patternsIt).patternNumber] == 1) sizeInter++;
                }        
                //resumo << "\tpattern:" << (*patternsIt).patternNumber << "\thi:" << h[i][(*patternsIt).patternNumber]  
                //          << "\thj:" << h[j][(*patternsIt).patternNumber] << std::endl;         
            }    
            w[i][j] = (double) sizeInter / (double)(size1 + size2 - sizeInter);
            if (w[i][j] > 0) nEdges++;
            
            //resumo << "size1: " << size1 << "\tsize2: " << size2 << "\tsizeInter: " << sizeInter << "\t";
            //resumo << "w:\t" << w[i][j] << std::endl;
        }    
    }    
    
    //resumo.close();
                                
    int w_int;             
    graph << nVertices << "\t" << nEdges << "\t1" << std::endl;
    for (int i = begin_hP1; i <= end_hP1; i++)
    {
        bool written = false;
        for (int j = begin_hP2; j <= end_hP2; j++)
        {
            if (w[i][j] != 0)
            {
                w_int = (int) ceil(w[i][j] * 10000);
                graph << j << "\t" << w_int << "\t";
                written = true;
            }    
        }    
        if (written) graph << std::endl;        
    }    
    for (int j = begin_hP2; j <= end_hP2; j++)
    {
        bool written = false;
        for (int i = begin_hP1; i <= end_hP1; i++)
        {
            if (w[i][j] != 0)
            {
                w_int = (int) ceil(w[i][j] * 10000);
                graph << i << "\t" << w_int  << "\t";
                written = true;
            }    
        }    
              
        if (written) graph << std::endl; 
    }        
    graph.close();
    
    //std::cout << "graph constructed" << std::endl;

    // chose the number of clusters of the child    
    // the child will have the number of clusters randomly choosen between the number or
    // clusters of the parents
    int nClustersChild;
    int minK = min(kP1, kP2);
    int maxK = max(kP1, kP2);
    nClustersChild = randomInt(minK, maxK);
    
//    if (kP1 <= kP2)
//        nClustersChild = randomInt(kP1, kP2);
//    else nClustersChild = randomInt(kP2, kP1);

//    std::cout << "kP1: " << kP1 << "\tkP2: " << kP2 << "\tfilho: " << nClustersChild << std::endl;

    string command;
    switch (runningSystem)
    {
        case mylinux:
        {           
            command = "gpmetis -dbglvl=0 " + graphName.string() + " " +
                      boost::lexical_cast<string>(nClustersChild);
            break;
        }    
        case mywindows:
        {           
            command = "gpmetis " + graphName.string() + " " +
                      boost::lexical_cast<string>(nClustersChild);
            break;
        }    
    }    

    system(command.c_str());

    fs::path resultName;
    fs::ifstream res;

    resultName = graphName.string() + ".part." + boost::lexical_cast<string>(nClustersChild);
    //std::cout << resultName.string() << std::endl;
    res.open(resultName);
    if (!res.good()) 
    {
        std::cout << "\nError in the file '" << resultName.string() << "'\n";
        getchar();
        exit(-1);
    }    
 

    // depois de particionar:
        
    std::map<int, vector<int> > mc; // meta-clusters: int -> numero do mc, vector<int> -> clusters que compoem mc
    std::map<int, std::map<int, double> > association; // level of association of each object to the mc 
                                                       // int -> mc, int -> object, double -> association level 
 
    int metaclu;
    indH = begin_hP1;
    mc.clear();
    while (!res.eof())
    {
        res >> metaclu;
        if (!res.fail())
        {
            mc[metaclu].insert(mc[metaclu].end(), indH);
            //std::cout << "mc: " << metaclu << "\indH: " << indH << std::endl;
            indH++;
        }    
    }

    res.close();

    for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
         patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
    {
        for (std::map<int, vector<int> >::iterator mcIt = mc.begin(); mcIt != mc.end(); mcIt++)
        {
            association[(*mcIt).first][(*patternsIt).patternNumber] = 0.0;
            //std::cout << "h: ";
            for (vector<int>::iterator iH = (*mcIt).second.begin(); iH != (*mcIt).second.end(); iH++)
            {
                association[(*mcIt).first][(*patternsIt).patternNumber] += h[(*iH)][(*patternsIt).patternNumber];
                //std::cout << "indH:" << (*iH) << " - " << h[(*iH)][(*patternsIt).patternNumber] << "\t";
            }
            if ((*mcIt).second.size() != 0.0)
                association[(*mcIt).first][(*patternsIt).patternNumber] /= (*mcIt).second.size();
            //std::cout << std::endl << "id: " << (*patternsIt).patternNumber << "\tmc: " << (*mcIt).first << "\tassociation: " << association[(*mcIt).first][(*patternsIt).patternNumber] << std::endl << std::endl << std::endl;
        }    
    }    
               
    std::map<int, int> highestAssociation; // int -> object, int -> mc
    for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
         patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
    {
        highestAssociation[(*patternsIt).patternNumber] = 0; // primeiro meta-cluster
        for (int i = 1; i < mc.size(); i++) // come�a do 1 para comparar com o anterior
        {
            if (association[i][(*patternsIt).patternNumber] > association[highestAssociation[(*patternsIt).patternNumber]][(*patternsIt).patternNumber])
                highestAssociation[(*patternsIt).patternNumber] = i;
        }    
        //std::cout << "id: " << (*patternsIt).patternNumber << "\tmc (highest association): " << highestAssociation[(*patternsIt).patternNumber] << std::endl;
    }    
    
    
    int newLable = 0;

    map <int, int> clusterCorrespondence;
    map <int, int>::iterator ccIterator;                        
            
    for (tPatterns::tPatternsDescriptionIt patternsIt = parent1.truePartition->patterns->patternsDescription.begin();
         patternsIt != parent1.truePartition->patterns->patternsDescription.end(); patternsIt++)
    {
        tPartition::tClustersIt clustersIt = solutionPartition.clusters.begin();
        bool found = false;
        while (!found && (clustersIt != solutionPartition.clusters.end())) 
        {
            ccIterator = clusterCorrespondence.find(highestAssociation[(*patternsIt).patternNumber]);
            if (ccIterator == clusterCorrespondence.end())
            {
                newLable++;
                clusterCorrespondence[highestAssociation[(*patternsIt).patternNumber]] = newLable;
            }   
            if ((*clustersIt).clusterLabel == clusterCorrespondence[highestAssociation[(*patternsIt).patternNumber]]) found = true;
            else clustersIt++;
        }    

        if (found)
        {
            (*clustersIt).insertPattern((*patternsIt).patternNumber);                                          
        }
        else
        {
            cCluster myCluster;
            myCluster.clusterLabel = clusterCorrespondence[highestAssociation[(*patternsIt).patternNumber]];
            myCluster.insertPattern((*patternsIt).patternNumber);
            solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
        }
    }         
    
    // a solucao deve ter o numero de clusters entre os numeros dos pais, caso contrario, um dos pais �
    // retornado como solucao
    if (solutionPartition.nClusters() < minK)
    {
        if (minK == kP1)
            solutionPartition = parent1.solutionPartition;
        else
            solutionPartition = parent2.solutionPartition;
    }
    
//    solutionPartition.showPartition();
//    getchar();
        
    remove_all(graphDir);
}





//crossover com uniao aleatoria dos potenciais grupos do filho
void TPartitionSolution::randomUnion(TPartitionSolution &parent1, TPartitionSolution &parent2) 
{
    // crossover parecido com o escrito na tese de Cole-1998, mas combinando os subgrupos iniciais (interseccoes
    // nao vazias) dois a dois ate atingir um numero de clusters tambem
    // aleatorio que pode estar entre os numeros de clusters dos pais. Os clusters do filho a serem combinados
    // seram escolhidos aleatoriamente entre os que resultam em uma uniao com o menor numero de elementos
    // na diferenca em relacao aos clusters dos pais
    
    std::vector <set<int> > intersections;
    set <int> intersection;
    insert_iterator<set<int> > itIntersection(intersection, intersection.begin());
    
    tPartition::tClustersIt clusterIt1, clusterIt2;
    
//    std::cout << "entrei na recombinacao" << std::endl;
//    getchar();
    
    // acha as interseccoes nao vazias dos clusters dos dois pais
    for (clusterIt1 = parent1.solutionPartition.clusters.begin();
         clusterIt1 != parent1.solutionPartition.clusters.end();
         clusterIt1++)
    {
        for (clusterIt2 = parent2.solutionPartition.clusters.begin();
             clusterIt2 != parent2.solutionPartition.clusters.end();
             clusterIt2++)
        {
//            std::cout << std::endl << "cluster part 1 : ";
//            for (set <int>::iterator it1 = (*parent1.solutionPartition.clustersIt).patterns.begin(); 
//                 it1 != (*parent1.solutionPartition.clustersIt).patterns.end(); 
//                 it1++)
//            {
//                std::cout << (*it1) << " ";
//            }
//            std::cout << std::endl << "cluster part 2 : ";
//            for (set <int>::iterator it2 = (*parent2.solutionPartition.clustersIt).patterns.begin(); 
//                 it2 != (*parent2.solutionPartition.clustersIt).patterns.end(); 
//                 it2++)
//            {
//                std::cout << (*it2) << " ";
//            }
//            std::cout << std::endl;
            set_intersection((*clusterIt1).patterns.begin(), 
                             (*clusterIt1).patterns.end(),
                             (*clusterIt2).patterns.begin(), 
                             (*clusterIt2).patterns.end(),
                             itIntersection);
            if (!intersection.empty())
                intersections.insert(intersections.end(), intersection);
            intersection.clear();
        }
    }
    
    std::vector <set<int> >::iterator itIntersections;
    set <int>::iterator it1;
//    for (itIntersections = intersections.begin(); itIntersections != intersections.end(); itIntersections++)
//    {
//        std::cout << "Intersection" << std::endl;
//        for (it1 = (*itIntersections).begin(); it1 != (*itIntersections).end(); it1++)
//        {
//            std::cout << (*it1) << " ";
//        }
//        std::cout << std::endl;
//    }

    // choose the number of clusters of the child
    int nClustersParent1 = parent1.solutionPartition.nClusters();
    int nClustersParent2 = parent2.solutionPartition.nClusters();
    // the child will have the number of clusters randomly choosen between the number or
    // clusters of the parents
    int nClustersChild;
    if (nClustersParent1 <= nClustersParent2)
        nClustersChild = randomInt(nClustersParent1, nClustersParent2);
    else nClustersChild = randomInt(nClustersParent2, nClustersParent1);
    
//    std::cout << std::endl << "pai1: " << nClustersParent1 << " - pai2: " << nClustersParent2 << " - nClustersChild: " << nClustersChild << std::endl;



    // join pairs of groups until the number of clusters of the child
    // be achieved
    int nClusters = intersections.size();
    while (nClusters > nClustersChild)
    {
        std::vector< set<int> > possibleClusters;
        std::vector<int> differenceSize;
        std::vector<pair<int, int> > clustersOfOrigin;
        
        for (std::vector <set<int> >::iterator itC1 = intersections.begin();
             itC1 != intersections.end();
             itC1++)
        {
            for (std::vector <set<int> >::iterator itC2 = itC1+1;
                 itC2 != intersections.end();
                 itC2++)
            {
//                std::cout << std::endl << "primeiro cluster: ";
//                for (std::set<int>::iterator it = (*itC1).begin(); it != (*itC1).end(); it++)
//                    std::cout << (*it) << " ";
//                
//                std::cout << std::endl << "segundo cluster: ";
//                for (std::set<int>::iterator it = (*itC2).begin(); it != (*itC2).end(); it++)
//                    std::cout << (*it) << " ";

                 
                set<int> newCluster;
                insert_iterator<set<int> > itNewCluster(newCluster, newCluster.begin());
                set_union((*itC1).begin(), (*itC1).end(), (*itC2).begin(), (*itC2).end(), itNewCluster);
                possibleClusters.insert(possibleClusters.end(), newCluster);
                int d1 = distance(intersections.begin(), itC1);
                int d2 = distance(intersections.begin(), itC2);
                clustersOfOrigin.insert(clustersOfOrigin.end(), make_pair(d1, d2));

//                std::cout << std::endl << "Uniao de " << d1 << " e " << d2 << ": ";
//                for (std::set<int>::iterator it = newCluster.begin(); it != newCluster.end(); it++)
//                    std::cout << (*it) << " ";
//                std::cout << std::endl;    
        
                // acha o valor m�nimo, entre todos os clusters de ambos os pais, do n�mero
                // de inst�ncias que est�o presentes no cluster (newCluster) do filho e n�o
                // est�o no cluster do pai.
                int diff = truePartition->nPatterns();
                int diffAux;
                
//                std::cout  << std::endl << "Diferencas: " << std::endl;   
                
                for (clusterIt1 = parent1.solutionPartition.clusters.begin();
                     clusterIt1 != parent1.solutionPartition.clusters.end();
                     clusterIt1++)
                {
                    set<int> clusterDifference;
                    insert_iterator<set<int> > itClusterDifference(clusterDifference, clusterDifference.begin());
                    set_difference(newCluster.begin(), 
                                   newCluster.end(),
                                   (*clusterIt1).patterns.begin(), 
                                   (*clusterIt1).patterns.end(),
                                   itClusterDifference);
                    diffAux = clusterDifference.size();
                    if (diffAux < diff) diff = diffAux;
                
//                    std::cout << "Cluster do pai: ";
//                    for (std::set<int>::iterator it = (*clusterIt1).patterns.begin(); it != (*clusterIt1).patterns.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl;    
//
//                    std::cout << "Dif: ";
//                    for (std::set<int>::iterator it = clusterDifference.begin(); it != clusterDifference.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl << "tamanho da diferenca: " << diffAux << std::endl;;                      
                                        
                }

                for (clusterIt1 = parent2.solutionPartition.clusters.begin();
                     clusterIt1 != parent2.solutionPartition.clusters.end();
                     clusterIt1++)
                {
                    set<int> clusterDifference;
                    insert_iterator<set<int> > itClusterDifference(clusterDifference, clusterDifference.begin());
                    set_difference(newCluster.begin(), 
                                   newCluster.end(),
                                   (*clusterIt1).patterns.begin(), 
                                   (*clusterIt1).patterns.end(),
                                   itClusterDifference);
                    diffAux = clusterDifference.size();
                    if (diffAux < diff) diff = diffAux;
                
//                    std::cout << "Cluster do pai: ";
//                    for (std::set<int>::iterator it = (*clusterIt1).patterns.begin(); it != (*clusterIt1).patterns.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl;    
//
//                    std::cout << "Dif: ";
//                    for (std::set<int>::iterator it = clusterDifference.begin(); it != clusterDifference.end(); it++)
//                        std::cout << (*it) << " ";
//                    std::cout << std::endl << "tamanho da diferenca: " << diffAux << std::endl;                     
                                        
                }
                                
//                std::cout << std::endl << "menor diferenca: " << diff << std::endl;;  
                
                differenceSize.insert(differenceSize.end(), diff);
            }
             
        }
            
        // acha todos os clusters da interseccao que tem o menor valor da diferenca calculada acima
        vector<int>::const_iterator itMin = min_element(differenceSize.begin(), differenceSize.end());
        
//        std::cout << "Menor valor entre todas as diferencas: " << (*itMin) << std::endl;
//        std::cout << "Possiveis clusters: " << std::endl;
         
        vector<int> positionsMin;
        for (int i = 0; i < differenceSize.size(); i++)
        {
             if (differenceSize[i] == (*itMin))
             {   
                 // guarda as posicoes no vetor de clusters possiveis onde estao
                 // localizados os clusters com a menor diferenca
                 positionsMin.insert(positionsMin.end(), i);
                 
//                 std::cout << "cluster " << i << ": ";
//                 for (std::set<int>::iterator it = possibleClusters[i].begin(); it != possibleClusters[i].end(); it++)
//                     std::cout << (*it) << " ";
//                 std::cout << std::endl;    
             }
        } 
        
        // sorteia um dos cluster com menor valor da diferenca para ser o cluster resultante
        int pos = randomInt(0, positionsMin.size()-1);
        int c = positionsMin[pos];
        
        int c1 = clustersOfOrigin[c].first;
        int c2 = clustersOfOrigin[c].second;
        
        // apaga os dois grupos que foram unidos e insere o novo grupo maior
        std::vector <set<int> >::iterator itC1;
        itC1 = intersections.begin();
        advance(itC1, c1);
        std::vector <set<int> >::iterator itC2;
        itC2 = intersections.begin();
        advance(itC2, c2);    
        // inserting or deleting an element in the middle of a vector invalidates 
        // all iterators that point to elements following the insertion or deletion point.            
        if (c1 < c2)
        {
            intersections.erase(itC2);
            intersections.erase(itC1);            
        }        
        else
        {
            intersections.erase(itC1);
            intersections.erase(itC2);            
        }        
        intersections.insert(intersections.end(), possibleClusters[c]);
        nClusters--;

//        std::cout << "Novo cluster " << c << ": ";       
//        for (std::set<int>::iterator it = possibleClusters[c].begin(); it != possibleClusters[c].end(); it++)
//            std::cout << (*it) << " ";
//        std::cout << std::endl;    
//
//            std::cout << "novas interseccoes" << std::endl;
//            for (itIntersections = intersections.begin(); itIntersections != intersections.end(); itIntersections++)
//            {
//                std::cout << "Intersection" << std::endl;
//                for (it1 = (*itIntersections).begin(); it1 != (*itIntersections).end(); it1++)
//                {
//                    std::cout << (*it1) << " ";
//                }
//                std::cout << std::endl;
//            }

    }

    // Put the final result in the proper structure in solutionPartition (child)
    for (int i = 0; i < intersections.size(); i++)
    {
        cCluster myCluster;
        myCluster.clusterLabel = i + 1;
        myCluster.patterns = intersections[i];
        solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
    }
}


//  crossover unindo clusters do filho aleatoriamente
//TPartitionSolution::TPartitionSolution(TPartitionSolution &parent1, TPartitionSolution &parent2): 
//    TMOMHSolution(parent1, parent2), 
//    truePartition(parent1.truePartition), 
//    solutionPartition(parent1.truePartition.patterns)
//{
//    // crossover descrito na tese de Cole-1998, so que combinando os subgrupos iniciais (interseccoes
//    // nao vazias) escolhendo dois a dois aleatoriamente, ate atingir um numero de clusters tambem
//    // aleatorio que pode estar entre os numeros de clusters dos pais
//    
//    std::vector <set<int> > intersections;
//    set <int> intersection;
//    insert_iterator<set<int> > itIntersection(intersection, intersection.begin());
//    
//    tPartition::tClustersIt clusterIt1, clusterIt2;
//    
//    // acha as interseccoes nao vazias dos clusters dos dois pais
//    for (clusterIt1 = parent1.solutionPartition.clusters.begin();
//         clusterIt1 != parent1.solutionPartition.clusters.end();
//         clusterIt1++)
//    {
//        for (clusterIt2 = parent2.solutionPartition.clusters.begin();
//             clusterIt2 != parent2.solutionPartition.clusters.end();
//             clusterIt2++)
//        {
////            std::cout << std::endl << "cluster part 1 : ";
////            for (set <int>::iterator it1 = (*parent1.solutionPartition.clustersIt).patterns.begin(); 
////                 it1 != (*parent1.solutionPartition.clustersIt).patterns.end(); 
////                 it1++)
////            {
////                std::cout << (*it1) << " ";
////            }
////            std::cout << std::endl << "cluster part 2 : ";
////            for (set <int>::iterator it2 = (*parent2.solutionPartition.clustersIt).patterns.begin(); 
////                 it2 != (*parent2.solutionPartition.clustersIt).patterns.end(); 
////                 it2++)
////            {
////                std::cout << (*it2) << " ";
////            }
////            std::cout << std::endl;
//            set_intersection((*clusterIt1).patterns.begin(), 
//                             (*clusterIt1).patterns.end(),
//                             (*clusterIt2).patterns.begin(), 
//                             (*clusterIt2).patterns.end(),
//                             itIntersection);
//            if (!intersection.empty())
//                intersections.insert(intersections.end(), intersection);
//            intersection.clear();
//        }
//    }
//    
////    std::vector <set<int> >::iterator itIntersections;
////    set <int>::iterator it1;
////    for (itIntersections = intersections.begin(); itIntersections != intersections.end(); itIntersections++)
////    {
////        std::cout << "Intersection" << std::endl;
////        for (it1 = (*itIntersections).begin(); it1 != (*itIntersections).end(); it1++)
////        {
////            std::cout << (*it1) << " ";
////        }
////        std::cout << std::endl;
////    }
//    // choose the number of clusters of the child
//    int nClustersParent1 = parent1.solutionPartition.nClusters();
//    int nClustersParent2 = parent2.solutionPartition.nClusters();
//    // the child will have the number of clusters randomly choosen between the number or
//    // clusters of the parents
//    int nClustersChild;
//    if (nClustersParent1 <= nClustersParent2)
//        nClustersChild = randomInt(nClustersParent1, nClustersParent2);
//    else nClustersChild = randomInt(nClustersParent2, nClustersParent1);
//    
////    std::cout << "pai1: " << nClustersParent1 << " - pai2: " << nClustersParent2 << " - nClustersChild: " << nClustersChild << std::endl;
//
//    // join pairs of groups, randomly choosen, until the number of clusters of the child
//    // be achieved
//    int nClusters = intersections.size();
//    while (nClusters > nClustersChild)
//    {
//        int c1 = randomInt(0, nClusters-1);
//        int c2 = randomInt(0, nClusters-1);
//        
////        std::cout << "clusters unidos " << std::endl;
////        std::cout << "c1: " << c1 << std::endl;
////        for (set <int>::iterator it2 = intersections[c1].begin(); 
////             it2 != intersections[c1].end(); 
////             it2++)
////        {
////            std::cout << (*it2) << " ";
////        }
////        std::cout << std::endl;
////
////        std::cout << "c2: " << c2 << std::endl;
////        for (set <int>::iterator it2 = intersections[c2].begin(); 
////             it2 != intersections[c2].end(); 
////             it2++)
////        {
////            std::cout << (*it2) << " ";
////        }
////        std::cout << std::endl;
//        
//        if (c1 != c2)
//        {
//            set<int> newCluster;
//            insert_iterator<set<int> > itNewCluster(newCluster, newCluster.begin());
//            set_union(intersections[c1].begin(), 
//                      intersections[c1].end(),
//                      intersections[c2].begin(), 
//                      intersections[c2].end(),
//                      itNewCluster);
//                      
////         std::cout << "novo cluster: " << std::endl;
////         for (set <int>::iterator it2 = newCluster.begin(); 
////             it2 != newCluster.end(); 
////             it2++)
////        {
////            std::cout << (*it2) << " ";
////        }
////        std::cout << std::endl;
////        std::cout << std::endl;
//           
//            // apaga os dois grupos que foram unidos e insere o novo grupo maior
//            std::vector <set<int> >::iterator itC1;
//            itC1 = intersections.begin();
//            advance(itC1, c1);
//            std::vector <set<int> >::iterator itC2;
//            itC2 = intersections.begin();
//            advance(itC2, c2);    
//            // inserting or deleting an element in the middle of a vector invalidates 
//            // all iterators that point to elements following the insertion or deletion point.            
//            if (c1 < c2)
//            {
//                intersections.erase(itC2);
//                intersections.erase(itC1);            
//            }        
//            else
//            {
//                intersections.erase(itC1);
//                intersections.erase(itC2);            
//            }        
//            intersections.insert(intersections.end(), newCluster);
//            nClusters--;
//            
////            std::cout << "novas interseccoes" << std::endl;
////            for (itIntersections = intersections.begin(); itIntersections != intersections.end(); itIntersections++)
////            {
////                std::cout << "Intersection" << std::endl;
////                for (it1 = (*itIntersections).begin(); it1 != (*itIntersections).end(); it1++)
////                {
////                    std::cout << (*it1) << " ";
////                }
////                std::cout << std::endl;
////            }
//
//        }
//    }
//
//    // Put the final result in the proper structure in solutionPartition (child)
//    for (int i = 0; i < intersections.size(); i++)
//    {
//        cluster myCluster;
//        myCluster.clusterLabel = i + 1;
//        myCluster.patterns = intersections[i];
//        solutionPartition.clusters.insert(solutionPartition.clusters.end(), myCluster);
//    }
//    
//    if (Objectives [nClusters_obj].bActive) 
//        ObjectiveValues[nClusters_obj] = solutionPartition.nClusters();
//    if (Objectives [informationGain_obj].bActive) 
//        ObjectiveValues[informationGain_obj] = informationGain(solutionPartition);
//    if (Objectives [connectivity_obj].bActive) 
//        ObjectiveValues[connectivity_obj] = connectivity(solutionPartition);
//    if (Objectives [correctedRand_obj].bActive) 
//        ObjectiveValues[correctedRand_obj] = correctedRand(solutionPartition, *truePartition);
//    if (Objectives [purity_obj].bActive) 
//        ObjectiveValues[purity_obj] = purity(solutionPartition);
//    if (Objectives [deviation_obj].bActive) 
//        ObjectiveValues[deviation_obj] = deviation(solutionPartition);
//    if (Objectives [deviationPearson_obj].bActive) 
//        ObjectiveValues[deviationPearson_obj] = deviationPearson(solutionPartition);
//    if (Objectives [connectivityPearson_obj].bActive) 
//        ObjectiveValues[connectivityPearson_obj] = connectivityPearson(solutionPartition);
//}

void TPartitionSolution::Mutate ()
{
   int clusterRemove, clusterInsert, nClu, pat;
   
   // sorteia os clusters para a mutacao
   nClu = solutionPartition.clusters.size(); // numero de clusters no vetor de clusters
   // sorteia um numero entre 0 e nClu 
//   clusterRemove = rand() % (nClu-1); // cluster do qual sera removido um padr�o
//   clusterInsert = rand() % (nClu-1); // cluster ao qual sera adicionado o padr�o removido do outro cluster
   clusterRemove = randomInt(0, nClu - 1); // cluster do qual sera removido um padr�o
   clusterInsert = randomInt(0, nClu - 1); // cluster ao qual sera adicionado o padr�o removido do outro cluster

   if (clusterRemove != clusterInsert)
   {      
      pat = solutionPartition.clusters[clusterRemove].randomPattern(); // sorteia um padr�o dentro do cluster que tera um padr�o removido
      
//      std::cout << "Particao antes de remover padrao de um cluster" << std::endl;
//      solutionPartition.showPartition();
      
      solutionPartition.clusters[clusterRemove].removePattern(pat);
      
//      std::cout << "Particao depois de remover padrao de um cluster" << std::endl;
//      solutionPartition.showPartition();

      solutionPartition.clusters[clusterInsert].insertPattern(pat);
      
//      std::cout << "Particao depois de adicionar padrao a um cluster" << std::endl;
//      solutionPartition.showPartition();

      // se o cluster do qual foi removido um padrao ficou vazio, removo esse cluster da particao
      if (solutionPartition.clusters[clusterRemove].nPatterns() == 0)
      {
         tPartition::tClustersIt clusterIt1;
         clusterIt1 = solutionPartition.clusters.begin();
         advance(clusterIt1, clusterRemove);
         solutionPartition.clusters.erase(clusterIt1);
      }
      
//      std::cout << "Particao depois de remover cluster vazio se houver" << std::endl;
//      solutionPartition.showPartition();
      
   }
   
   solutionPartition.calculateCentroids();
   
    if (Objectives [nClusters_obj].bActive) 
        ObjectiveValues[nClusters_obj] = solutionPartition.nClusters();
    if (Objectives [informationGain_obj].bActive) 
        ObjectiveValues[informationGain_obj] = informationGain(solutionPartition);
    if (Objectives [connectivity_obj].bActive) 
        ObjectiveValues[connectivity_obj] = connectivity(solutionPartition);
    if (Objectives [correctedRand_obj].bActive) 
        ObjectiveValues[correctedRand_obj] = correctedRand(solutionPartition, *truePartition);
    if (Objectives [purity_obj].bActive) 
        ObjectiveValues[purity_obj] = purity(solutionPartition);
    if (Objectives [deviation_obj].bActive) 
        ObjectiveValues[deviation_obj] = deviation(solutionPartition);
    if (Objectives [deviationPearson_obj].bActive) 
        ObjectiveValues[deviationPearson_obj] = deviationPearson(solutionPartition);
    if (Objectives [connectivityPearson_obj].bActive) 
        ObjectiveValues[connectivityPearson_obj] = connectivityPearson(solutionPartition);
}

double TPartitionSolution::correctedRand(tPartition &Pe, tPartition &Pr)
{     
    return cr(Pe, Pr);
}


//// Count the number of patterns of a class (patternClass) in a vector of patterns (clustersContents). The class should be 
//// a substring in the string of the vector (in the pattern ID).
//int TPartitionSolution::countClass(int patternClass, std::vector<string> &clustersContents)
//{
//    int nPat = 0;
//    for (std::vector<string>::iterator it = clustersContents.begin(); it != clustersContents.end(); it++)
//    {
////        if (patternClass == "hyperdip")
////           std::cout << (*it) << std::endl;
//        if ((*it).find(patternClass, 0) != string::npos)
//        {
//             nPat++;
//        }
//    }
//    //std::cout << patternClass << ": " << nPat << std::endl;
// 
//    return nPat;
//}


double TPartitionSolution::purity(tPartition &Pe)
{ 
   int nPatPred;
   int nPatAll;
   double purity = 0.0;
           
   cCluster::tPatternsIt patItPe, patItPr;

   for (int i = 0; i < Pe.nClusters(); i++)
   {
      nPatPred = Pe.nPatternsPredominantClass(Pe.clusters[i]); 
      nPatAll = Pe.clusters[i].nPatterns();
      purity +=  (double)nPatPred / (double)nPatAll;
//      std::cout << "n patterns pred class: " << nPatPred << std::endl;
//      std::cout << "n patterns all: " << nPatAll << std::endl;
//      std::cout << "purity: " << purity << std::endl;
   }
   purity /= Pe.nClusters();
   return purity; 
}

double TPartitionSolution::informationGain(tPartition &Pe)
{ 

  double s1 = 0, s2 = 0, s3 = 0;
  int nPat = truePartition->nPatterns();
  
//  std::cout << "nPat: " << nPat << std::endl;
  
  for (int i = 0; i < truePartition->nClusters(); i++)
  {
      double pc = (double)truePartition->clusters[i].nPatterns() / nPat;
//      std::cout << "Pc: " << pc << std::endl;
      if (pc != 0) s1 += pc * log2(pc);
  }
//  std::cout << "S1: " << s1 << std::endl;
  
  for (int j = 0; j < Pe.nClusters(); j++)
  {
      int nElemCluster = Pe.clusters[j].nPatterns();
      double pk = (double)nElemCluster / nPat;
      
//      std::cout << "pk: " << pk << std::endl;
      
      s2 = 0;
      for (int i = 0; i < truePartition->nClusters(); i++)
      {
          cCluster::tPatternsIt it = truePartition->clusters[i].patterns.begin();
          
//          std::cout << truePartition.patterns.patternClass(*it) << std::endl;
          double pck = (double)Pe.nPatternsClass(truePartition->patterns->patternClass(*it), Pe.clusters[j]) / nElemCluster;
//          std::cout << "Pck: " << pck << std::endl;
          if (pck != 0) s2 += pck * log2(pck);
      }
//      std::cout << "S2: " << s2 << std::endl;

      s3 += pk * s2;
  }
//  std::cout << "S3: " << s3 << std::endl;

   double gain = - s1 + s3;
   
//   std::cout << "Gain: " << gain << std::endl;
//   getchar();
   return gain; 
}


double TPartitionSolution::connectivity(tPartition &Pe)
{ 


    double conn = 0.0;
    int nPat = truePartition->nPatterns();
    float nn = ceil (nPat * 0.05); // number of nearest neighbors is 5% of the size of the dataset
    int nNearestNeighbors = int(nn);
    //std::cout << "nn: " << nNearestNeighbors << std::endl;
  
    //std::cout << "Pattern " << (*it1).patternNumber << std::endl;
    //std::cout << " j-esimo vizinho " << "1/j" << "somaNN" << "conn" << std::endl;
    for (tPatterns::tPatternsDescriptionIt it1 = Pe.patterns->patternsDescription.begin();
         it1 != Pe.patterns->patternsDescription.end(); it1++)
    {
		//std::cout << std::endl << "Pattern " << (*it1).patternNumber;
        double somaNN = 0.0;
        for (int j = 0; j < nNearestNeighbors; j++)
        {
			if (Pe.clusterOf((*it1).patternNumber) !=
				Pe.clusterOf(Pe.patterns->nnList[(*it1).patternNumber][j]))
			{
				double jj = (j + 1);
				somaNN += 1.0 / jj; // j + 1 porque j � 0 para o 1o vizinho... 
			}
			//std::cout << " j+1 " << j + 1;
			//std::cout << " 1.0/(j+1) " << 1.0/(j+1) << " somaNN " << somaNN;
        }    
        conn += somaNN;
		//std::cout << std::endl << " c " << conn << std::endl;
    }    
   std::cout << "Connectivity: " << conn << std::endl << std::endl;
   //getchar();
   return conn; 
}

double TPartitionSolution::connectivityPearson(tPartition &Pe)
{ 
    double conn = 0;
    int nPat = truePartition->nPatterns();
    float nn = ceil (nPat * 0.05); // number of nearest neighbors is 5% of the size of the dataset
    int nNearestNeighbors = int(nn);
    //std::cout << "nn: " << nNearestNeighbors << std::endl;
  
//    std::cout << "Pattern " << (*it1).patternNumber << std::endl;
    //std::cout << " j-esimo vizinho " << "1/j" << "somaNN" << "conn" << std::endl;
    for (tPatterns::tPatternsDescriptionIt it1 = Pe.patterns->patternsDescription.begin();
         it1 != Pe.patterns->patternsDescription.end(); it1++)
    {
        //std::cout << "Pattern " << (*it1).patternNumber;
        double somaNN = 0;
        for (int j = 0; j < nNearestNeighbors; j++)
        {
            if (Pe.clusterOf((*it1).patternNumber) !=  
                Pe.clusterOf(Pe.patterns->nnListPearson[(*it1).patternNumber][j]))
                somaNN += 1.0/(j+1); // j + 1 porque j � 0 para o 1o vizinho... 
            //std::cout << " " << j + 1;
            //std::cout << " " << 1.0/(j+1) << " s" << somaNN;
        }    
        conn += somaNN;
        //std::cout << " c " << conn << std::endl;
    }    
//   std::cout << "Connectivity: " << conn << std::endl << std::endl;
//   getchar();
   return conn; 
}


// this objective is the overall deviation of a partitioning, and 
// measure the cluster compactness (Handl-2004, Multiobjective clustering with 
// automatic determination of the number of clusters
double TPartitionSolution::deviation(tPartition &Pe)
{ 
    double dev = 0.0;
    std::map<int, std::vector<double> > *centroids;
    std::map<int, std::vector<double> >::iterator centroidsIt;
    centroids = Pe.getCentroids();
    for (tPartition::tClustersIt itClu = Pe.clusters.begin(); 
         itClu != Pe.clusters.end(); itClu++)
    {
        //std::cout << "Cluster: " << (*itClu).clusterLabel << std::endl;
        int nAttributes = Pe.patterns->nAttributes();
      
        // calculate the summed distances for each pattern of a cluster
        for (cCluster::tPatternsIt itPat = (*itClu).patterns.begin();
             itPat != (*itClu).patterns.end(); itPat++)
        {
            //std::vector<double> pat = Pe.patterns.patternValues(*itPat);
            //centroids[(*itClu).clusterLabel];
            
            centroidsIt = centroids->find((*itClu).clusterLabel);
            double euclidean = euclideanDistance(Pe.patterns->patternValues(*itPat), (*centroidsIt).second);
            //double euclidean = euclideanDistance(Pe.patterns->patternValues(*itPat), centroids[(*itClu).clusterLabel].second);
            //std::cout << "Pattern: " << (*itPat) << " - distance: " << euclidean << std::endl;
            dev += euclidean;
        }    
    }    

   std::cout << "deviation: " << dev << std::endl << std::endl;
   //getchar();
   return dev; 
}

double TPartitionSolution::deviationPearson(tPartition &Pe)
{ 
    double dev = 0;
    std::map<int, std::vector<double> > *centroids;
    std::map<int, std::vector<double> >::iterator centroidsIt;
    centroids = Pe.getCentroids();
    for (tPartition::tClustersIt itClu = Pe.clusters.begin(); 
         itClu != Pe.clusters.end(); itClu++)
    {
        //std::cout << "Cluster: " << (*itClu).clusterLabel << std::endl;
        int nAttributes = Pe.patterns->nAttributes();
      
        // calculate the summed distances for each pattern of a cluster
        for (cCluster::tPatternsIt itPat = (*itClu).patterns.begin();
             itPat != (*itClu).patterns.end(); itPat++)
        {
            //std::vector<double> pat = Pe.patterns.patternValues(*itPat);
            //centroids[(*itClu).clusterLabel];
            
            centroidsIt = centroids->find((*itClu).clusterLabel);
            double pearson = pearsonCorrelation(Pe.patterns->patternValues(*itPat), (*centroidsIt).second);
            //double euclidean = euclideanDistance(Pe.patterns->patternValues(*itPat), centroids[(*itClu).clusterLabel].second);
            //std::cout << "Pattern: " << (*itPat) << " - distance: " << euclidean << std::endl;
            dev += pearson;
        }    
    }    

   //std::cout << "dev: " << dev << std::endl << std::endl;
   //getchar();
   return dev; 
}

//// Silhouette
//double TPartitionSolution::silhouette(tPartition &Pe)
//fs::path dataset, fs::path partitionFileName, t_similarities sim)
//{       
//    fs::path auxName;
//    
//    auxName = fs::basename(truePartition->dataset) + "_silhouette.txt";
//    fs::path silhoueteFileName = partitionFileName.branch_path() / auxName;
//    
//    fs::path silhouetteSummaryFileName = partitionFileName.branch_path() / (fs::basename(dataset) + "_silhouette_summary.txt");
//    
//    std::string command = "perl silhouetteVersao2.pl " + strSimilarities(sim) + " " + dataset.string() + " " + 
//              partitionFileName.string() + " " + silhoueteFileName.string();
//    system(command.c_str());
//    
//    fs::ifstream file;
//    file.open(silhouetteSummaryFileName);
//    if (!file.good()) 
//    {
//        std::cout << "\nError in the file " << silhouetteSummaryFileName.string() << std::endl;
//        getchar();
//    }
//    
//    int cluster;
//    double silhouette, averageSilhouette;
//    
//    file.ignore(maxFileLine, '\n');
//    while (!file.eof())
//    {
//        file >> cluster >> silhouette;
//        if (!file.fail())
//        {
//            if (cluster == 0) averageSilhouette = silhouette;
//            //std::cout << "c: " << cluster << "\ts: " << silhouette << std::endl;
//        }
//    }
//    file.close();
//
//    return averageSilhouette;
//}

