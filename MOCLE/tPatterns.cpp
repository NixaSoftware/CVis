// Class automatically generated by Dev-C++ New Class wizard

#include "tPatterns.h" // class's header file


TPatternDescription::TPatternDescription(const TPatternDescription &patternDescription)
{
      patternNumber = patternDescription.patternNumber;    
      patternLabel = patternDescription.patternLabel;
      patternClass = patternDescription.patternClass;
      values = patternDescription.values;

}

TPatternDescription::TPatternDescription()
{
      patternNumber = 0;    
      patternLabel = "";
      patternClass = -1;
      values.resize(0);
}



// class constructor
tPatterns::tPatterns()//fs::path ds)
{
    dataset = "";
    patternsDescription.clear();
    distanceMatrix.clear();
    nnList.clear();
    correlationMatrix.clear();
    nnListPearson.clear();

//    std::cout << "entrei no tPatterns()" << std::endl;
//    getchar();

}

tPatterns::tPatterns(const tPatterns &pat)
{
//    std::cout << "teste - entrei no tPatterns(tPatterns)" << std::endl;
//    getchar();

    dataset = pat.dataset;
    patternsDescription = pat.patternsDescription;
    distanceMatrix = pat.distanceMatrix;
    nnList = pat.nnList;

    correlationMatrix = pat.correlationMatrix;
    nnListPearson = pat.nnListPearson;

//    generateDistanceMatrix();
//    generatennList();        

//    patternsDescription.patternNumber = pat.patternsDescription.patternNumber;
//    patternsDescription.patternLabel = pat.patternsDescription.patternLabel;
//    patternsDescription.patternClass = pat.patternsDescription.patternClass;

    
 //   for (std::vector <TPatternDescription>::iterator it = patternsDescription.begin();
//         it != patternsDescription.end(); it++)
//    {       
//        std::cout << "Pattern: " << (*it).patternNumber << ", Label: " << (*it).patternLabel 
//                  << ", Class: " << (*it).patternClass << std::endl;        
//    }
//getchar();
}
/* ds é o dataset com o caminho do diretório do mesmo*/
/* filePatterns - particao conhecida*/
tPatterns::tPatterns(fs::path &ds, fs::path &filePatterns) 
{
//    std::cout << "entrei no tPatterns(filePatterns, fileClass)" << std::endl;
//    getchar();

	// inicializando o atributo dataset
    dataset = ds;
	// 
    std::string id;
    int clu;
    fs::ifstream file;
    fs::ifstream fileDataset;
    
    //fs::ifstream classFile;
    
    char line[maxFileLine];
    std::string line2, identifier, s;
    std::vector<std::string> header;

    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    std::map<std::string, std::vector<double>, cmp> pat;
    
//    // read the classes label 
//    classFile.open(fileClasses);
//    if (!classFile.good()) 
//    {
//        std::cout << "\nError in the file " << fileClasses.string() << std::endl;
//        getchar();
//        exit(-1);
//    }
//    std::set<std::string> pClasses;
//    std::string pClass;    
//    while (!classFile.eof())
//    {
//        classFile >> pClass;
//        pClasses.insert(pClass);
////        std::cout << pClass << std::endl;
//    }
//    classFile.close();

    // carrega dataset
    fileDataset.open(dataset);
    if (!fileDataset.good()) 
    {
        std::cout << "\nError in the file '" << dataset.string() << "'\n";
        getchar();
        exit(-1);
    }

    fileDataset.getline(line, maxFileLine);
    line2 = line;
    tokenizer tokens(line2, sep);
    for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
    {
    	std::string s = *tok_iter;
        header.insert(header.end(), s);
    }
    
	// lendo o iris.txt
    while (!fileDataset.eof())
    {
        fileDataset.getline(line, maxFileLine);
        if (!fileDataset.fail())
        {
            line2 = line;
            tokens.assign(line2, sep);
    
            for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
            {
                if (tok_iter == tokens.begin())
                {
                   identifier = *tok_iter;
                }
                else
                {
                    s = *tok_iter; 
                    
                    pat[identifier].insert(pat[identifier].end(), atof(s.c_str())); 
                }            
            }
        }    
   }
   fileDataset.close();

    int number = firstPatternNumber;
    TPatternDescription pattern;
    file.open(filePatterns);
    if (!file.good()) 
    {
        std::cout << "\nError in the file '" << filePatterns.string() << "'\n";
        getchar();
        exit(-1);
    }  
    // lendo do Iris Real
    while (!file.eof())
    {
        file >> id >> clu;
        if (!file.fail())
        {               
            pattern.patternLabel = id;
            pattern.patternNumber = number;
            number++;
            pattern.patternClass = clu;
            // find the label of the class of a pattern
//            bool foundClass = false;;
//            std::set<std::string>::iterator itPClasses = pClasses.begin();
//            while (!foundClass && (itPClasses != pClasses.end()))
//            {
//                if (id.find((*itPClasses), 0) != std::string::npos)
//                {
//                    foundClass = true;
//                    pattern.patternClass = *itPClasses;
//                }
//                itPClasses++;
//            }
            pattern.values = pat[id];
            patternsDescription.insert(patternsDescription.end(), pattern);
        }                       
    }
    file.close();  
    
//    for (std::vector <TPatternDescription>::iterator it = patternsDescription.begin();
//         it != patternsDescription.end(); it++)
//    {
//        std::cout << "Pattern: " << (*it).patternNumber << ", Label: " << (*it).patternLabel 
//                  << ", Class: " << (*it).patternClass 
//                  << "Values: " << std::endl;        
//        for (std::vector<double>::iterator i = (*it).values.begin(); i != (*it).values.end(); i++)
//        {
//            std::cout << (*i) << ", ";
//        }    
//        std::cout << std::endl;
//    }

    generateDistanceMatrix();
    generatennList();        
    generateCorrelationMatrix();
    generatennListPearson();        
}





int tPatterns::patternClass(int number)
{   
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (itPatternsDescription != patternsDescription.end() && !found) 
    {
        if ((*itPatternsDescription).patternNumber == number) found = true;
        else itPatternsDescription++;
    }    
    if (itPatternsDescription == patternsDescription.end())
        return -1;
    else
        return (*itPatternsDescription).patternClass;
}
            
int tPatterns::patternClass(std::string label)
{
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (!found && (itPatternsDescription != patternsDescription.end())) 
    {
        if ((*itPatternsDescription).patternLabel == label) found = true;
        else itPatternsDescription++;
    }    
    if (!found)
        return -1;
    else
        return (*itPatternsDescription).patternClass;
}
            
int tPatterns::patternNumber(std::string label)
{
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (!found && (itPatternsDescription != patternsDescription.end())) 
    {
        if ((*itPatternsDescription).patternLabel == label) found = true;
        else itPatternsDescription++;
    }    
    if (!found)
        return -1;
    else
        return (*itPatternsDescription).patternNumber;
}

            
std::string tPatterns::patternLabel(int number)
{
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (!found && (itPatternsDescription != patternsDescription.end())) 
    {
        if ((*itPatternsDescription).patternNumber == number) found = true;
        else itPatternsDescription++;
    }    
    if (!found)
        return "";
    else
        return (*itPatternsDescription).patternLabel;

}
            
            
std::vector<double> tPatterns::patternValues(int number)
{   
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (itPatternsDescription != patternsDescription.end() && !found) 
    {
        if ((*itPatternsDescription).patternNumber == number) found = true;
        else itPatternsDescription++;
    }    
    if (itPatternsDescription == patternsDescription.end()) exit -1;
    return (*itPatternsDescription).values;
}
            
std::vector<double> tPatterns::patternValues(std::string label)
{
    std::vector <TPatternDescription>::iterator itPatternsDescription = patternsDescription.begin();
    bool found = false;
    while (!found && (itPatternsDescription != patternsDescription.end())) 
    {
        if ((*itPatternsDescription).patternLabel == label) found = true;
        else itPatternsDescription++;
    }    
    if (!found) exit -1;
    return (*itPatternsDescription).values;
}

            
int tPatterns::nPatterns()
{
//    std::cout << "nPatterns: " << patternsDescription.size();    
//    showPatterns();
//    getchar();
    return patternsDescription.size();
}

int tPatterns::nAttributes()
{
    if (patternsDescription.size() == 0)
    {
        std::cout << "No pattern loaded" << std::endl;
        exit(-1);
    }    
    else return patternsDescription[0].values.size();
}    

void tPatterns::showPatterns()
{
    std::vector <TPatternDescription>::iterator itPatternsDescription;
    for (itPatternsDescription = patternsDescription.begin();
         itPatternsDescription != patternsDescription.end();
         itPatternsDescription++)
    {
         
        std::cout << "Pattern: " << (*itPatternsDescription).patternNumber <<
                     "Label: " << (*itPatternsDescription).patternLabel <<
                     "Class: " << (*itPatternsDescription).patternClass << std::endl;

    }
}


void tPatterns::generateDistanceMatrix()
{
    double distance;
//    int nPat = nPatterns();
//    distanceMatrix.resize(nPat);
//    for (std::vector<std::vector<double> >::iterator i = distanceMatrix.begin();
//         i != distanceMatrix.end(); i++)
//    {
//        (*i).resize(nPat);
//        fill((*i).begin(), (*i).end(), 0);
//    }   
//     
//    for (tPatternsDescriptionIt it1 = patternsDescription.begin();
//         it1 != patternsDescription.end(); it1++)
//    {        
//        for (tPatternsDescriptionIt it2 = it1;
//             it2 != patternsDescription.end(); it2++)
//        {
//            distance = euclideanDistance((*it1).values, (*it2).values);
//            distanceMatrix[(*it1).patternNumber - 1][(*it2).patternNumber - 1] = distance;
//            distanceMatrix[(*it2).patternNumber - 1][(*it1).patternNumber - 1] = distance;
//        }    
//    }    
//    
//    for (int i = 0; i < patternsDescription.size(); i++)
//    {
//        for (int j = 0; j < patternsDescription.size(); j++)
//        {
//            std::cout << distanceMatrix[i][j] << " ";
//        }    
//        std::cout << std::endl;
//    }    
      
    for (tPatternsDescriptionIt it1 = patternsDescription.begin();
         it1 != patternsDescription.end(); it1++)
    {        
        for (tPatternsDescriptionIt it2 = it1;
             it2 != patternsDescription.end(); it2++)
        {
//            std::cout << "Pattern 1: " << (*it1).patternLabel << std::endl;
//            std::cout << "Pattern 2: " << (*it2).patternLabel << std::endl;
            distance = euclideanDistance((*it1).values, (*it2).values);
            distanceMatrix[(*it1).patternNumber][(*it2).patternNumber] = distance;
            distanceMatrix[(*it2).patternNumber][(*it1).patternNumber] = distance;
        }    
    }    

//    for (std::map<int, std::map<int, double> >::iterator i = distanceMatrix.begin();
//         i != distanceMatrix.end(); i++)
//    {
//        for (std::map<int, double>::iterator j = (*i).second.begin();
//         j != (*i).second.end(); j++)
//        {
//            std::cout << (*j).second << " ";
//        }    
//        std::cout << std::endl;
//    }    
        
}  

void tPatterns::generatennList()
{
//    int nPat = nPatterns();
//    distanceMatrix.resize(nPat); 
//    for (std::vector<std::vector<int> >::iterator i = nnList.begin();
//         i != nnList.end(); i++)
//    {
//        (*i).resize(nPat - 1); // n�o considera o pr�prio padr�o
//        fill((*i).begin(), (*i).end(), 0);
//    }    

    
    for (tPatternsDescriptionIt it1 = patternsDescription.begin();
         it1 != patternsDescription.end(); it1++)
    {   
        std::vector<std::pair<int, double> > distances; 
        for (std::map<int, double>::iterator it2 = distanceMatrix[(*it1).patternNumber].begin();
             it2 != distanceMatrix[(*it1).patternNumber].end(); it2++)
        {            
            distances.insert(distances.end(), std::make_pair((*it2).first, (*it2).second));
            //std::cout << (*it2).second << " ";
        }        
        
        stable_sort(distances.begin(), distances.end(), patternCmp());
        
        for (std::vector<std::pair<int, double> >::iterator it2 = distances.begin();
             it2 != distances.end(); it2++)
        {
            //std::cout << (*it2).second << " ";
            if ((*it2).first != (*it1).patternNumber)
            {
                nnList[(*it1).patternNumber].insert(nnList[(*it1).patternNumber].end(), (*it2).first);
            }    
        }  
//        std::cout << "Pattern " << (*it1).patternNumber << ": ";
//        for (int i = 0; i < nnList[(*it1).patternNumber].size(); i++)
//            std::cout << nnList[(*it1).patternNumber][i] << " ";
//        std::cout << std::endl;
    }        
}    


void tPatterns::generateCorrelationMatrix()
{
    double correlation; 
      
    for (tPatternsDescriptionIt it1 = patternsDescription.begin();
         it1 != patternsDescription.end(); it1++)
    {        
        for (tPatternsDescriptionIt it2 = it1;
             it2 != patternsDescription.end(); it2++)
        {
//            std::cout << "Pattern 1: " << (*it1).patternLabel << std::endl;
//            std::cout << "Pattern 2: " << (*it2).patternLabel << std::endl;
            correlation = pearsonCorrelation((*it1).values, (*it2).values);
            //std::cout << "pearson: " << correlation << std::endl;
            correlationMatrix[(*it1).patternNumber][(*it2).patternNumber] = correlation;
            correlationMatrix[(*it2).patternNumber][(*it1).patternNumber] = correlation;
        }    
    }    

//    for (std::map<int, std::map<int, double> >::iterator i = correlationMatrix.begin();
//         i != correlationMatrix.end(); i++)
//    {
//        for (std::map<int, double>::iterator j = (*i).second.begin();
//         j != (*i).second.end(); j++)
//        {
//            std::cout << (*j).second << " ";
//        }    
//        std::cout << std::endl;
//    }    
//    getchar();        
}  

void tPatterns::generatennListPearson()
{   
    for (tPatternsDescriptionIt it1 = patternsDescription.begin();
         it1 != patternsDescription.end(); it1++)
    {   
        std::vector<std::pair<int, double> > correlations; 
        for (std::map<int, double>::iterator it2 = correlationMatrix[(*it1).patternNumber].begin();
             it2 != correlationMatrix[(*it1).patternNumber].end(); it2++)
        {            
            correlations.insert(correlations.end(), std::make_pair((*it2).first, (*it2).second));
            //std::cout << (*it2).second << " ";
        }        
        
        stable_sort(correlations.begin(), correlations.end(), patternCmp());
        
        for (std::vector<std::pair<int, double> >::iterator it2 = correlations.begin();
             it2 != correlations.end(); it2++)
        {
            //std::cout << (*it2).second << " ";
            if ((*it2).first != (*it1).patternNumber)
            {
                nnListPearson[(*it1).patternNumber].insert(nnListPearson[(*it1).patternNumber].begin(), (*it2).first); // insere no inicio pois a ordem dos vizinhos mais correlacionadas eh decrescente (o vizinho mais correlacionado eh o de maior correlacao de Pearson)
            }    
        }  
//        std::cout << "Pattern " << (*it1).patternNumber << ": ";
//        for (int i = 0; i < nnListPearson[(*it1).patternNumber].size(); i++)
//            std::cout << nnListPearson[(*it1).patternNumber][i] << " ";
//        std::cout << std::endl;
//        getchar();
    }        
}    

