// Class automatically generated by Dev-C++ New Class wizard

#include "combiner.h" // class's header file

// class constructor
combiner::combiner(fs::path &ds, fs::path &expDir, fs::path &dirInitialPop, tPartition *tp) :
//           patterns(fileTruePartition, fileClasses),
           experimentsDir(expDir),
           truePartition(tp),
           dirInitialPopulation(dirInitialPop),//expDir.string() + "/initialPopulation"),
           partitionSolution(dirInitialPopulation, truePartition)
{    
//    truePartition.showPartition();
//    getchar();
    dataset = ds;
    resultFile = expDir / "objectiveValues.txt";
    //dirInitialPopulation = expDir / "initialPopulation";
	dirSolutionPopulation = expDir / "solutionPopulation";

//    std::cout << "resultFile: " << resultFile.string() << std::endl;
//    std::cout << "dirInitialPopulation: " << dirInitialPopulation.string() << std::endl;
//    std::cout << "dirSolutionPopulation: " << dirSolutionPopulation.string() << std::endl;
//    getchar();


    NumberOfObjectives = 8;
    Objectives.resize (NumberOfObjectives);
    
    // number of clusters
    Objectives[nClusters_obj].ObjectiveType = _Max;
    Objectives[nClusters_obj].bActive = false;
    // information gain - (Raileanu-2004)
    Objectives[informationGain_obj].ObjectiveType = _Max;
    Objectives[informationGain_obj].bActive = false;
    // connectivity - (Handl-2005)
    Objectives[connectivity_obj].ObjectiveType = _Min;
    Objectives[connectivity_obj].bActive = false;
    // corrected Rand
    Objectives[correctedRand_obj].ObjectiveType = _Max;
	Objectives[correctedRand_obj].bActive = false;
    // purity
    Objectives[purity_obj].ObjectiveType = _Max;
	Objectives[purity_obj].bActive = false;
    // deviation
    Objectives[deviation_obj].ObjectiveType = _Min;
    Objectives[deviation_obj].bActive = false;  
    // deviation Pearson
    Objectives[deviationPearson_obj].ObjectiveType = _Max;
    Objectives[deviationPearson_obj].bActive = false;
    // connectivity Pearson
    Objectives[connectivityPearson_obj].ObjectiveType = _Min;
    Objectives[connectivityPearson_obj].bActive = false;
    
    for (std::vector<t_objectives>::iterator objIt = objType.begin(); objIt != objType.end(); objIt++)
    {
        Objectives[*objIt].bActive = true;
    }    

//    // number of clusters
//    Objectives[0].ObjectiveType = _Max;
//	if (expType == semisupervised2)
//	{
//	    Objectives[0].bActive = true;
//	    //std::cout << "k true" << std::endl;
//    }
//	else
//        Objectives[0].bActive = false;
//
//    // information gain - (Raileanu-2004)
//    Objectives[1].ObjectiveType = _Max;
//    //Objectives[1].bActive = false;
//	if ((expType == semisupervised)	|| (expType == semisupervised2))
//	{
//        Objectives[1].bActive = true;
//        //std::cout << "gain true" << std::endl;
//    }    
//    else
//        Objectives[1].bActive = false;
//
//    // connectivity - (Handl-2005)
//    Objectives[2].ObjectiveType = _Min;
//    if (expType != semisupervised2)
//    {
//	    Objectives[2].bActive = true;
//	    //std::cout << "conn true" << std::endl;
//    }
//    else
//    {
//	    Objectives[2].bActive = false;
//	    //std::cout << "conn false" << std::endl;
//    }
//
//    // corrected Rand
//    Objectives[3].ObjectiveType = _Max;
//	Objectives[3].bActive = false;
// 
//    // purity
//    Objectives[4].ObjectiveType = _Max;
//	Objectives[4].bActive = false;
//
//    // deviation
//    Objectives[5].ObjectiveType = _Min;
//	if (expType != semisupervised2)
//	{
//        Objectives[5].bActive = true;
//        //std::cout << "dev true" << std::endl;
//    }
//    else
//    {
//        Objectives[5].bActive = false;
//        //std::cout << "dev false" << std::endl;
//    }
//    
//    // deviation Pearson
//    Objectives[6].ObjectiveType = _Max;
//    Objectives[6].bActive = false;
//
//    // connectivity Pearson
//    Objectives[7].ObjectiveType = _Min;
//    Objectives[7].bActive = true;
}

// class destructor
combiner::~combiner()
{
	// insert your code here
}

void combiner::runCombiner(int nGenerations, double mutationProbability)//, int nNearestNeighbors)
{

//    std::cout << "experimentsDir: " << experimentsDir.string() << std::endl;
//    std::cout << "dirInitialPopulation: " << dirInitialPopulation.string() << std::endl;
//    std::cout << "dirSolutionPopulation: " << dirSolutionPopulation.string() << std::endl;
//    std::cout << "nGenerations: " << nGenerations << std::endl;
//    std::cout << "mutationProbability: " << mutationProbability << std::endl;
//    getchar();

    // NSGAII    
    partitionSolution.SetParameters(dirInitialPopulation, 100, nGenerations, mutationProbability, true);
    // SPEA
//    partitionSolution.SetParameters(experimentsDir, dirInitialPopulation, 100, nGenerations, mutationProbability, 30, 30, true);
    partitionSolution.Run();

/*	//trecho usado anteriormente para testar uma particao - avaliar conectividade e compactacao por exemplo
	fs::directory_iterator endDir; 
	for (fs::directory_iterator dirIt(dirInitialPopulation); dirIt != endDir; dirIt++)
	{
		std::cout << (*dirIt) << std::endl;
		TPartitionSolution t((*dirIt), truePartition->patterns, truePartition);
		//TProblemSolution t = new TProblemSolution((*dirIt), truePartition->patterns, truePartition);  // acrescentei
	}
	cout << "tecle enter";
	getchar();
*/

//    char fileName[maxFileLine];
//    strcpy(fileName, resultFile.string().c_str());
//    partitionSolution.pNondominatedSet->Save (fileName);
    
    if (exists(dirSolutionPopulation))
       remove_all(dirSolutionPopulation);
    fs::create_directory(dirSolutionPopulation);
    partitionSolution.saveSolutionPopulation(dirSolutionPopulation, resultFile);

    //NondominatedSet.Save(resultFile.string());
}

