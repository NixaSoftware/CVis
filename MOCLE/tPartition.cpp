// Class automatically generated by Dev-C++ New Class wizard


#include "tPartition.h" // class's header file





bool tPartition::foundCluster(cCluster c, int clu)
{
    return c.clusterLabel == clu;
}


// class constructor

tPartition::tPartition() : patterns()
{
    dataset = "";
    clusters.clear();
    centroids.clear();
//    std::cout << "entrei no tPartition()" << std::endl;
//    getchar();
}

tPartition::tPartition(tPatterns *pat) : patterns(pat)
{
    dataset = pat->dataset;  
    clusters.clear(); 
    centroids.clear(); 
//    std::cout << "entrei no tPartition(tPattern)" << std::endl;
//    getchar();
//    nPat = 0;
}

tPartition::tPartition(const tPartition &part) : patterns(part.patterns)
{
//    std::cout << "teste - entrei no tPartition(tPartition)" << std::endl;
//    getchar();
    //nPat = part.nPat;
    dataset = part.dataset;
    clusters = part.clusters;
    centroids = part.centroids;
//        for (tPartition::tClustersIt clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }

}

tPartition::tPartition(fs::path &ds, fs::path &partitionFileName) // partitionFileName - particao conhecida
//    patterns(ds, partitionFileName, fileClasses)
{
//    std::cout << "entrei no tPartition(fileName, fileClass)" << std::endl;
//    getchar();

    patterns = new tPatterns(ds, partitionFileName);
    dataset = ds;

    std::string id;
    int clu;
    //tPatterns pattern;    
    fs::ifstream file;
    tPartition::tClustersIt clustersIt;
    
    //nPat = 0;
    file.open(partitionFileName);
    if (!file.good()) 
    {
        std::cout << "\nError in the file '" << partitionFileName.string() << "'\n";
        getchar();
        exit(-1);
    }    
    while (!file.eof())
    {
        file >> id >> clu;
        if (!file.fail())
        {           
// testar isso aqui                    
//            clustersIt = find_if((*clusters.begin()).clusterLabel, 
//                                 (*clusters.end()).clusterLabel, 
//                                 bind2nd(ptr_fun(foundCluster) clu));

            clustersIt = clusters.begin();
            bool found = false;
            while (!found && (clustersIt != clusters.end())) 
            {
                if ((*clustersIt).clusterLabel == clu) found = true;
                else clustersIt++;
            }    

           if (found)
           {
               (*clustersIt).insertPattern(patterns->patternNumber(id));                                          
           }
           else
           {
               cCluster myCluster;
               myCluster.clusterLabel = clu;
               myCluster.insertPattern(patterns->patternNumber(id));
               clusters.insert(clusters.end(), myCluster);
           }
//           nPat++;
        }
    }
    file.close();
    
//    for (clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }
    calculateCentroids();
}


tPartition::tPartition(fs::path &ds, fs::path &partitionFileName, tPatterns *pat) : patterns(pat)
{
//    std::cout << "entrei no tPartition(fileName, tPatterns)" << std::endl;
//    getchar();

    dataset = ds;
    std::string id;
    int clu;
    //tPatterns pattern;    
    fs::ifstream file;
    tPartition::tClustersIt clustersIt;

    //nPat = 0;
    file.open(partitionFileName);
    if (!file.good()) 
    {
        std::cout << "\nError in the file '" << partitionFileName.string() << "'\n";
        getchar();
        exit(-1);
    }    
    while (!file.eof())
    {
        file >> id >> clu;
        //std::cout << "inserindo padr�o " << id << " no cluster " << clu << std::endl;
        if (!file.fail())
        {           
// testar isso aqui                    
//            vector<cluster>::iterator itClusters = find_if((*clusters.begin()).clusterLabel, 
//                                                           (*clusters.end()).clusterLabel, 
//                                                           bind2nd(ptr_fun(foundCluster), clu));
            clustersIt = clusters.begin();
            bool found = false;
            while (!found && (clustersIt != clusters.end())) 
            {
                if ((*clustersIt).clusterLabel == clu) found = true;
                else clustersIt++;
            }    

           if (found)
           {
               (*clustersIt).insertPattern(patterns->patternNumber(id));                                          
           }
           else
           {
               cCluster myCluster;
               myCluster.clusterLabel = clu;
               myCluster.insertPattern(patterns->patternNumber(id));
               clusters.insert(clusters.end(), myCluster);
           }                                
           //nPat++;

        }
    }
    file.close();
//    for (clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }

    calculateCentroids();
}

// class destructor
tPartition::~tPartition()
{
	// insert your code here
}

int tPartition::nClusters()
{
   return clusters.size();
}

int tPartition::nPatterns()
{
   //return nPat;
   return patterns->nPatterns();
}

// return the label of the cluster of the pattern "pattern"
int tPartition::clusterOf(int pattern)
{
    for (tClustersIt it = clusters.begin(); it != clusters.end(); it++)
    {
        cCluster::tPatternsIt patternsIt = (*it).patterns.find(pattern);
        if (patternsIt != (*it).patterns.end())
            return (*it).clusterLabel;
    }    
    return -1;
}    

// count the number of patters of the predominant class of cluster c
int tPartition::nPatternsPredominantClass(cCluster c)
{
    std::map <int, int> nPat; // class, number of objexts of "class" in cluster c
    std::map <int, int>::iterator nPatIt;
    
    for (cCluster::tPatternsIt patternsIt = c.patterns.begin(); patternsIt != c.patterns.end(); patternsIt++)
    {
       nPatIt = nPat.find(patterns->patternClass(*patternsIt));
       if (nPatIt == nPat.end())
          nPat[patterns->patternClass(*patternsIt)] = 0;
       else
          nPat[patterns->patternClass(*patternsIt)]++;     
    }
    int maxPat = 0;
    for (nPatIt = nPat.begin(); nPatIt != nPat.end(); nPatIt++)
    {
       if (maxPat < (*nPatIt).second)
          maxPat = (*nPatIt).second;
    }
    return maxPat;
}

// count the number of patters of the class cl in the cluster c
int tPartition::nPatternsClass(int cl, cCluster c)// cl should contain the label of the class as in tPatterns
{    
    int nPat = 0;
    
    for (cCluster::tPatternsIt patternsIt = c.patterns.begin(); patternsIt != c.patterns.end(); patternsIt++)
    {
       if (patterns->patternClass(*patternsIt) == cl)
       {
           nPat++;
       }
    }
    return nPat;
}


void tPartition::calculateCentroids()
{    
    for (tPartition::tClustersIt itClu = clusters.begin(); 
         itClu != clusters.end(); itClu++)
    {
        //std::cout << "Cluster: " << (*itClu).clusterLabel << std::endl;
        int nAttributes = patterns->nAttributes();
        // calculate the centroid of cluster itClu
        centroids[(*itClu).clusterLabel].resize(nAttributes);
        //std::cout << "centroide: ";
        for (int a = 0; a < nAttributes; a++)
        {
            
            //std::cout << "Cluster: " << (*itClu).clusterLabel << std::endl << "Patterns: ";
//            getchar();
            //centroid[(*itClu).clusterLabel].insert(centroid[(*itClu).clusterLabel].end(), 0);
            centroids[(*itClu).clusterLabel][a] = 0;
            for (cCluster::tPatternsIt itPat = (*itClu).patterns.begin();
                 itPat != (*itClu).patterns.end(); itPat++)
            {
                centroids[(*itClu).clusterLabel][a] += patterns->patternValues(*itPat)[a];
                //std::cout << (*itPat) << " " << centroid[(*itClu).clusterLabel][a] << std::endl;
            }    
            centroids[(*itClu).clusterLabel][a] /= (*itClu).nPatterns();
            //std::cout << " " << centroid[(*itClu).clusterLabel][a];
        }    
        //std::cout << std::endl;        
        //getchar();
    }    
}    

std::map<int, std::vector<double> > *tPartition::getCentroids()
{
    if (centroids.empty())
    {
        std::cout << "Centroids are not calculated." << std::endl;
        exit -1;
    }
    return &centroids;
}    



void tPartition::showPartition()
{
    for (tPartition::tClustersIt clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
    {
        (*clustersIt).showCluster();
        std::cout << std::endl;
    }

}


// Print the clustering in the file <fileName>
void tPartition::savePartition(fs::path &fileName)
{

    fs::ofstream file;

    file.open(fileName);
    if (file.bad()) 
    {
        std::cout << "\nCannot open file '" << fileName.string() << "'\n";
        getchar();
        exit(-1);
    }
    
    for (tPartition::tClustersIt clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
    {
        for (cCluster::tPatternsIt patternsIt = (*clustersIt).patterns.begin(); patternsIt != (*clustersIt).patterns.end(); patternsIt++)
        {
           file << patterns->patternLabel(*patternsIt) << "\t" << (*clustersIt).clusterLabel << std::endl;
//           std::cout << patterns.patternLabel(*patternsIt) << "\t" << (*clustersIt).clusterLabel << std::endl;
        }
    }

   file.close();
}

void tPartition::randomPartition(tPatterns *pat, int k, fs::path &fileName)
{

    std::string id;
    int clu;
    //tPatterns pattern;    
    fs::ifstream file;
    tPartition::tClustersIt clustersIt;

    patterns = pat;

    clusters.clear();

    int nClusters = randomInt(2, k);    
    
//    std::cout << "k: " << nClusters << std::endl;
    
    for (tPatterns::tPatternsDescriptionIt patIt = patterns->patternsDescription.begin();
         patIt != patterns->patternsDescription.end();
         patIt++)
    {
        clu = randomInt(1, nClusters); //????? ver se aqui � isso mesmo
        clustersIt = clusters.begin();
        bool found = false;
        while (!found && (clustersIt != clusters.end())) 
        {
            if ((*clustersIt).clusterLabel == clu) found = true;
            else clustersIt++;
        }    

       if (found)
       {
           (*clustersIt).insertPattern((*patIt).patternNumber);                                          
       }
       else
       {
           cCluster myCluster;
           myCluster.clusterLabel = clu;
           myCluster.insertPattern((*patIt).patternNumber);
           clusters.insert(clusters.end(), myCluster);
       }                               
    } 
    savePartition(fileName);
    calculateCentroids();

//    for (clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }

}

void tPartition::randomPartition(tPatterns *pat, int k)
{

    std::string id;
    int clu;
    //tPatterns pattern;    
    fs::ifstream file;
    tPartition::tClustersIt clustersIt;

    patterns = pat;

    clusters.clear();

    int nClusters = randomInt(2, k);    
    
//    std::cout << "k: " << nClusters << std::endl;
    
    for (tPatterns::tPatternsDescriptionIt patIt = patterns->patternsDescription.begin();
         patIt != patterns->patternsDescription.end();
         patIt++)
    {
        clu = randomInt(0, nClusters - 1);
        clustersIt = clusters.begin();
        bool found = false;
        while (!found && (clustersIt != clusters.end())) 
        {
            if ((*clustersIt).clusterLabel == clu) found = true;
            else clustersIt++;
        }    

       if (found)
       {
           (*clustersIt).insertPattern((*patIt).patternNumber);                                          
       }
       else
       {
           cCluster myCluster;
           myCluster.clusterLabel = clu;
           myCluster.insertPattern((*patIt).patternNumber);
           clusters.insert(clusters.end(), myCluster);
       }                               
    } 

//    for (clustersIt = clusters.begin(); clustersIt != clusters.end(); clustersIt++)
//    {
//        (*clustersIt).showCluster();
//    }
    calculateCentroids();
}
