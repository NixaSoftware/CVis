// Class automatically generated by Dev-C++ New Class wizard

#include "dbscan.h" // class's header file

using std::string;

const double dbscan::epsDefault;
const int dbscan::minptsDefault;

// class constructor
dbscan::dbscan(std::string datasetName, std::string fileResultName, t_similarities sim, double aux_eps = epsDefault, int aux_minpts = minptsDefault)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    eps = aux_eps;
    minpts = aux_minpts;
}

dbscan::dbscan(string datasetName, string fileResultName, t_similarities sim = euclidean)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    eps = epsDefault;
    minpts = minptsDefault;
}


dbscan::dbscan()
{
	dataset = "";
	fileResult = "";
    similarity = euclidean;
    eps = epsDefault;
    minpts = minptsDefault;
}

dbscan::dbscan(std::string datasetName, std::string fileResultName, t_similarities sim, std::string parameters)
{
    dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    eps = epsDefault;
    minpts = minptsDefault;
    
    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
        if (*ti == "-eps")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            eps = atof((*ti).c_str());
            if ((eps == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "CN: " << CN << std::endl;
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "sim: " << similarity << std::endl;
        }
        else if (*ti == "-minpts")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            minpts = atoi((*ti).c_str());
            if ((minpts == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "vt: " << VT << std::endl;
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }  
}


dbscan::dbscan(std::string parameters)
{
    dataset = "";
	fileResult = "";
    similarity = euclidean;
    eps = epsDefault;
    minpts = minptsDefault;
    
    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
        if (*ti == "-eps")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            eps = atof((*ti).c_str());
            if ((eps == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "CN: " << CN << std::endl;
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "sim: " << similarity << std::endl;
        }
        else if (*ti == "-minpts")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            minpts = atoi((*ti).c_str());
            if ((minpts == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "vt: " << VT << std::endl;
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }  
}


// class destructor
//dbscan::~dbscan()
//{
//	// insert your code here
//}

dbscan::dbscan(const dbscan &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    eps = a.eps;
    minpts = a.minpts;
    p = a.p;
} 

dbscan & dbscan::operator = (const dbscan &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    eps = a.eps;
    minpts = a.minpts;
    p = a.p;
} 

cpartition dbscan::run()
{ 
    string command, sim;

//    switch(similarity) 
//    {
//        case euclidean:   sim = "euclidean"; break;
//        case pearson:   sim = "correlation"; break;
//    }
        
    if (runningSystem == mywindows)
        command = "./dbscan " + dataset + " " + fileResult + " "; // +  sim;
    else
        command = "./dbscan " + dataset + " " + fileResult + " "; // +  sim;
    command += boost::lexical_cast<string>(eps);
    command += " ";
    command += boost::lexical_cast<string>(minpts);
    
    system(command.c_str());

    string fileClu = fileResult + ".clu"; 
    p.loadPartition(fileClu);
    p.printPartition(fileClu); // to make the labeling starts at 1

    return p;

}

void dbscan::changeDataset(std::string datasetName)
{
     dataset = datasetName;
}

void dbscan::changeResultFile(std::string fileResultName)
{
     fileResult = fileResultName;
}

void dbscan::changeSimilarity(t_similarities sim)
{
     similarity = sim;
}

void dbscan::changeEps(double aux_eps)
{
     eps = aux_eps;
}

void dbscan::changeMinpts(int aux_minpts)
{
     minpts = aux_minpts;
}

cpartition dbscan::getPartition()
{
    return p;
}

//dbscan::t_cells dbscan::getCells()
//{    
//     
////    t_cells clusterCenters;
//
//    fs::ifstream file2,file3;
//    char line[maxFileLine];
//    string line2, identifier, s;
//
//    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
//    boost::char_separator<char> sep("\t ");
//    std::map<std::string, std::vector<double>, cmp> pat;
// 
//    // load the correspondence between nodes and clusters in sota results
//    std::map<int, int > clustersNodes;
//    int node, cluster;    
//    string fileCorrespondence = fileResult + ".clu.correspondence";
//    //string fileCorrespondence = fileAlgorithmPartition.string() + ".clu.correspondence";
//    //std::cout << fileCorrespondence << std::endl;
//    file2.open(fileCorrespondence);
//    if (!file2.good()) 
//    {
//        std::cout << "\nError in the file '" << fileCorrespondence << "'\n";
//        getchar();
//    }    
//    while (!file2.eof())
//    {
//        file2 >> cluster >> node;
//        //std::cout << cluster << std::endl;
//        //getchar();
//        clustersNodes[node] = cluster;
//    }
//    file2.close();
//    
//    //getchar();
//
//    std::map<int, std::vector<double> > clustersCenters;
//
//    // read the cells of the file .cod generated with sotarray 6.0
//    string fileSotaCells = fileResult + ".cod";
//    //string fileSotaCells = fileAlgorithmPartition.string() + ".cod";
//    //char nodeWord[10], sign[10];
//    file3.open(fileSotaCells);
//    if (!file3.good()) 
//    {
//        std::cout << "\nError in the file '" << fileSotaCells << "'\n";
//        getchar();
//    }
//    
//    file3.getline(line, maxFileLine);
//    file3.getline(line, maxFileLine);
//    
//    while (!file3.eof())
//    {
//        file3.getline(line, maxFileLine);
//        
//        sscanf(line, "%*s%d", &node);
////        strcmp(sign, "->")
//        if (strstr(line, "->"))
//        {
//            file3.ignore(maxFileLine, '\n');
//            //std::cout << "tem sign" << std::endl;
////            std::cout << nodeWord << std::endl;
//            //std::cout << node << std::endl;
//        }
//        else
//        {     
//            //std::cout << "entrou no else" << std::endl;     
//            //std::cout << node << std::endl;
//            file3.getline(line, maxFileLine);
//            line2 = line;
//            tokenizer tokens(line2, sep);
//            //tokens.assign(line2, sep);
//            for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
//            {
//                s = *tok_iter; 
//                //std::cout << s << std::endl;
//                clustersCenters[clustersNodes[node]].insert(clustersCenters[clustersNodes[node]].end(), atof(s.c_str()));
//                //pat[identifier].insert(pat[identifier].end(), atof(s.c_str())); 
//            //std::cout << s.c_str() << std::endl;
//            }
//        }
//   }
//    file3.close();
//
////        std::map<int, std::vector<double> >::iterator patIterator;        
////        for (patIterator = clustersCenters.begin(); 
////        patIterator != clustersCenters.end(); 
////        patIterator++)    
////        {
////            std::cout << "First " << (*patIterator).first << std::endl;
////            for (std::vector<double>::iterator v = (*patIterator).second.begin(); v != (*patIterator).second.end(); ++v)
////            { 
////                std::cout << "Second " << *v << std::endl; 
////            }
////        }
////getchar();
//
//    return clustersCenters;
//}
