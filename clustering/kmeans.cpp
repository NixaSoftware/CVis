// Class automatically generated by Dev-C++ New Class wizard

#include "kmeans.h" // class's header file

using std::string;

const int kmeans::kDefault;
const int kmeans::nRunsDefault;

// class constructor
kmeans::kmeans(std::string datasetName, std::string fileResultName, 
               t_similarities sim = euclidean, int nClusters = kDefault, int auxnRuns = nRunsDefault)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    k = nClusters;
    nRuns = auxnRuns;
}

kmeans::kmeans()
{
	dataset = "";
	fileResult = "";
    similarity = euclidean;
    k = kDefault;
    nRuns = nRunsDefault;
}

kmeans::kmeans(std::string datasetName, std::string fileResultName, t_similarities sim, std::string parameters)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    k = kDefault;
    nRuns = nRunsDefault;

    //std::cout << "Par em kmeans (construtor): " << parameters << std::endl;
    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
        if (*ti == "-k")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            k = boost::lexical_cast<int>(*ti);
            if ((k == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "k: " << k << std::endl;
        }
        else if (*ti == "-r")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            nRuns = boost::lexical_cast<int>(*ti);;
            if ((nRuns == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "k: " << k << std::endl;
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "sim: " << similarity << std::endl;
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }
}

kmeans::kmeans(std::string parameters)
{
	dataset = "";
	fileResult = "";
    similarity = euclidean;
    k = kDefault;
    nRuns = nRunsDefault;

    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
        if (*ti == "-k")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            k = boost::lexical_cast<int>(*ti);
            if ((k == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "k: " << k << std::endl;
        }
        else if (*ti == "-r")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            nRuns = boost::lexical_cast<int>(*ti);;
            if ((nRuns == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "k: " << k << std::endl;
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }
}



// class destructor
//kmeans::~kmeans()
//{
//	// insert your code here
//}

kmeans::kmeans(const kmeans &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    k = a.k; 
    nRuns = a.nRuns;
    p = a.p;
    centroids = a.centroids;
} 

kmeans & kmeans::operator = (const kmeans &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    k = a.k; 
    nRuns = a.nRuns;
    p = a.p;
    centroids = a.centroids;
} 

cpartition kmeans::run()
{ 
    string command;
    string fileNameClu;
    string fileName;
    //char buffer[100];
    //string buffer;
    string id;
    int cluster;        
    
    if (runningSystem == mywindows)
        command = "cluster -f " + dataset.string() + " -u " + fileResult; 
    else
        command = "cluster -f " + dataset.string() + " -u " + fileResult; 
    
    // similarity metric to be employed'(available in the software
// 0: No gene clustering
    // 1: Uncentered correlation
    // 2: Pearson correlation
    // 3: Uncentered correlation, absolute value
    // 4: Pearson correlation, absolute value
    // 5: Spearman's rank correlation
    // 6: Kendall's tau
    // 7: Euclidean distance
    // 8: Harmonically summed Euclidean distance
    // 9: City-block distance
    // (default: 1)
    int sim;
    switch(similarity) 
    {
        case euclidean:   sim = 7; break;
        case pearson:   sim = 2; break;
//      default:   statement sequence; break;
    }
    command += " -g ";
    command += boost::lexical_cast<string>(sim);
    
    command += " -k ";
    command += boost::lexical_cast<string>(k);
    
    command += " -r ";
    command += boost::lexical_cast<string>(nRuns);
    
//    std::cout << "command: " << command << std::endl;
    
    system(command.c_str());
    
    std::ifstream file;
    std::ofstream fileClu;
    
    fileName = fileResult + ".clu";
    p.loadPartition(fileName);   
    p.printPartition(fileName); // to make the labeling starts at 1

    return p;
}

void kmeans::changeDataset(std::string datasetName)
{
    dataset = datasetName;
}

void kmeans::changeResultFile(std::string fileResultName)
{
    fileResult = fileResultName;
}

void kmeans::changeSimilarity(t_similarities sim)
{
    similarity = sim;
}

void kmeans::changeK(int nClusters) // number of clusters
{
    k = nClusters;
}

void kmeans::changeNRuns(int value)
{
    nRuns = value;
}

cpartition kmeans::getPartition()
{
    return p;
}

kmeans::t_centroids kmeans::getCentroids()
{
    int nDimensions;
    
    if (p.nPatterns() == 0)
    {
        std::cout << "You shoud run the algorithm before to get the centroids" << std::endl;
        getchar();
    }

// carrega o dataset
    fs::ifstream file;
    char line[maxFileLine];
    string line2, identifier, s;
    std::vector<string> header;
    
    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    std::map<std::string, std::vector<double>, cmp> pat;

    file.open(dataset);
    if (!file.good()) 
    {
        std::cout << "\nError in the file '" << dataset.string() << "'\n";
        getchar();
    }    
    file.getline(line, maxFileLine);
    line2 = line;
    tokenizer tokens(line2, sep);
    for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
    {
        header.insert(header.end(), *tok_iter);
    }
    nDimensions = header.size() -1 ;
    while (!file.eof())
    {
        file.getline(line, maxFileLine);
        line2 = line;
        tokens.assign(line2, sep);

        for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
        {
            if (tok_iter == tokens.begin())
            {
               identifier = *tok_iter;
            }
            else
            {
                s = *tok_iter; 
                pat[identifier].insert(pat[identifier].end(), atof(s.c_str())); 
            }
        }
   }
   file.close();


   // armazena o numero de padroes em cada cluster
    std::map<int, int> nPatternsCluster;

    std::set<int> clusterLabels;
    std::set<int>::iterator c;
    clusterLabels = p.getClustersLabels();

    for (c = clusterLabels.begin(); c != clusterLabels.end(); c++)
    {
        std::vector<double> v; // (nDimensions); // se nao colocar o tamanho, da erro no fill
        fill_n(back_inserter(v), nDimensions, 0);
//        for (int j = 0; j < nDimensions; j++) 
//        {
//            //centroids[*c].insert(v.end(), 0);
//            v.insert(v.end(), 0);            
//        }     
        //std::cout << "cluster " << *c << std::endl;   
        centroids[*c] = v;
        nPatternsCluster[*c] = 0;
    }


   std::map<std::string, std::vector<double>, cmp>::iterator patIterator;        
   cpartition::t_iterator_Patterns partitionIterator;
  
   
   // soma os valores dos padr�es de cada cluster
   for (patIterator = pat.begin(); patIterator != pat.end(); patIterator++)    
   {
       //(*currPe).first
       
       int cluster = (*p.find((*patIterator).first)).second;
       nPatternsCluster[cluster]++;
       //std::cout << "padrao: " << (*patIterator).first << std::endl;
       //std::cout << "cluster: " << cluster << std::endl;
       //std::cout << "nPatternsCluster: " << nPatternsCluster[cluster] << std::endl;

       for (int i = 0; i < nDimensions; i++)
       {
           centroids[cluster][i] += (*patIterator).second[i];
           //std::cout << "centroid: " << centroids[cluster][i] << std::endl;
       }
   }
   // media dos valores dos padr�es (centroides)
   for (c = clusterLabels.begin(); c != clusterLabels.end(); c++)
   {
       //std::cout << "cluster: " << *c << std::endl;
       for (int i = 0; i < nDimensions; i++)
       {
           centroids[*c][i] /= nPatternsCluster[*c];
           //std::cout << "centroid: " << centroids[*c][i] << std::endl;
       }
   }
       
   return centroids;
}

