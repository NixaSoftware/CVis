// Class automatically generated by Dev-C++ New Class wizard

#include "singlelink.h" // class's header file

using std::string;

const int singlelink::kDefault;

// class constructor
singlelink::singlelink(std::string datasetName, std::string fileResultName, 
                       t_similarities sim = euclidean, int auxk = kDefault)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    k = auxk;
}

singlelink::singlelink()
{
	dataset = "";
	fileResult = "";
    similarity = euclidean;
    k = kDefault;
}

singlelink::singlelink(std::string datasetName, std::string fileResultName, t_similarities sim, std::string parameters)
{
	dataset = datasetName;
	fileResult = fileResultName;
    similarity = sim;
    k = kDefault;

    //std::cout << "Par em kmeans (construtor): " << parameters << std::endl;
    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
        if (*ti == "-cut")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            k = boost::lexical_cast<int>(*ti);
            if ((k == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "sim: " << similarity << std::endl;
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }
}

singlelink::singlelink(std::string parameters)
{
	dataset = "";
	fileResult = "";
    similarity = euclidean;
    k = kDefault;

    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
    boost::char_separator<char> sep("\t ");
    tokenizer tokens(parameters, sep);
    
    tokenizer::iterator ti = tokens.begin();
    while (ti != tokens.end())
    {
       if (*ti == "-cut")
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            k = boost::lexical_cast<int>(*ti);
            if ((k == 0) && (*ti != "0"))
            {
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
        }
        else if (*ti == "-sim")  
        {
            ti++;
            if (ti == tokens.end()) {std::cout << "Error in the parameters." << std::endl; break;}
            if (*ti == "euclidean")
            {
                similarity = euclidean;
            } 
            else if (*ti == "pearson")
            {
                similarity = pearson;
            } 
            else
            {                
                std::cout << "Invalid parameter value: " << *ti << std::endl;
            }
            //std::cout << "sim: " << similarity << std::endl;
        }
        else std::cout << "Invalid parameter: " << *ti << std::endl;
        ti++;
    }
}



// class destructor
//singlelink::~singlelink()
//{
//	// insert your code here
//}

singlelink::singlelink(const singlelink &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    k = a.k; 
    p = a.p;
} 

singlelink & singlelink::operator = (const singlelink &a)
{
    dataset = a.dataset;
    fileResult = a.fileResult;
    similarity = a.similarity;
    k = a.k; 
    p = a.p;
} 

cpartition singlelink::run()
{ 
    string command;
    string fileNameClu;
    string fileName;
    string id;
    int cluster;        
    
    if (runningSystem == mywindows)    
        command = "cluster -f " + dataset.string() + " -u " + fileResult; 
    else
        command = "cluster -f " + dataset.string() + " -u " + fileResult; 
    
    // similarity metric to be employed'(available in the software
// 0: No gene clustering
    // 1: Uncentered correlation
    // 2: Pearson correlation
    // 3: Uncentered correlation, absolute value
    // 4: Pearson correlation, absolute value
    // 5: Spearman's rank correlation
    // 6: Kendall's tau
    // 7: Euclidean distance
    // 8: Harmonically summed Euclidean distance
    // 9: City-block distance
    // (default: 1)
    int sim;
    switch(similarity) 
    {
        case euclidean:   sim = 7; break;
        case pearson:   sim = 2; break;
    }

    command += " -g ";
    command += boost::lexical_cast<string>(sim);
    command += " -cut ";
    command += boost::lexical_cast<string>(k);
    command += " -m s"; // single-link

    system(command.c_str());
    
    fileName = fileResult + ".clu";
    p.loadPartition(fileName);
    p.printPartition(fileName); // to make the labeling starts at 1

    return p;

}

void singlelink::changeDataset(std::string datasetName)
{
    dataset = datasetName;
}

void singlelink::changeResultFile(std::string fileResultName)
{
    fileResult = fileResultName;
}

void singlelink::changeSimilarity(t_similarities sim)
{
    similarity = sim;
}

void singlelink::changeK(int value) // number of clusters
{
    k = value;
}

cpartition singlelink::getPartition()
{
    return p;
}

//singlelink::t_centroids kmeans::getCentroids()
//{
//    int nDimensions;
//    
//    if (p.nPatterns() == 0)
//    {
//        std::cout << "You shoud run the algorithm before to get the centroids" << std::endl;
//        getchar();
//    }
//
//// carrega o dataset
//    fs::ifstream file;
//    char line[maxFileLine];
//    string line2, identifier, s;
//    std::vector<string> header;
//    
//    typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
//    boost::char_separator<char> sep("\t ");
//    std::map<std::string, std::vector<double>, cmp> pat;
//
//    file.open(dataset);
//    if (!file.good()) 
//    {
//        std::cout << "\nError in the file '" << dataset.string() << "'\n";
//        getchar();
//    }    
//    file.getline(line, maxFileLine);
//    line2 = line;
//    tokenizer tokens(line2, sep);
//    for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
//    {
//        header.insert(header.end(), *tok_iter);
//    }
//    nDimensions = header.size() -1 ;
//    while (!file.eof())
//    {
//        file.getline(line, maxFileLine);
//        line2 = line;
//        tokens.assign(line2, sep);
//
//        for (tokenizer::iterator tok_iter = tokens.begin(); tok_iter != tokens.end(); ++tok_iter)
//        {
//            if (tok_iter == tokens.begin())
//            {
//               identifier = *tok_iter;
//            }
//            else
//            {
//                s = *tok_iter; 
//                pat[identifier].insert(pat[identifier].end(), atof(s.c_str())); 
//            }
//        }
//   }
//   file.close();
//
//
//   // armazena o numero de padroes em cada cluster
//    std::map<int, int> nPatternsCluster;
//
//    std::set<int> clusterLabels;
//    std::set<int>::iterator c;
//    clusterLabels = p.getClustersLabels();
//
//    for (c = clusterLabels.begin(); c != clusterLabels.end(); c++)
//    {
//        std::vector<double> v; // (nDimensions); // se nao colocar o tamanho, da erro no fill
//        fill_n(back_inserter(v), nDimensions, 0);
////        for (int j = 0; j < nDimensions; j++) 
////        {
////            //centroids[*c].insert(v.end(), 0);
////            v.insert(v.end(), 0);            
////        }     
//        //std::cout << "cluster " << *c << std::endl;   
//        centroids[*c] = v;
//        nPatternsCluster[*c] = 0;
//    }
//
//
//   std::map<std::string, std::vector<double>, cmp>::iterator patIterator;        
//   partition::t_iterator_Patterns partitionIterator;
//  
//   
//   // soma os valores dos padr�es de cada cluster
//   for (patIterator = pat.begin(); patIterator != pat.end(); patIterator++)    
//   {
//       //(*currPe).first
//       
//       int cluster = (*p.find((*patIterator).first)).second;
//       nPatternsCluster[cluster]++;
//       //std::cout << "padrao: " << (*patIterator).first << std::endl;
//       //std::cout << "cluster: " << cluster << std::endl;
//       //std::cout << "nPatternsCluster: " << nPatternsCluster[cluster] << std::endl;
//
//       for (int i = 0; i < nDimensions; i++)
//       {
//           centroids[cluster][i] += (*patIterator).second[i];
//           //std::cout << "centroid: " << centroids[cluster][i] << std::endl;
//       }
//   }
//   // media dos valores dos padr�es (centroides)
//   for (c = clusterLabels.begin(); c != clusterLabels.end(); c++)
//   {
//       //std::cout << "cluster: " << *c << std::endl;
//       for (int i = 0; i < nDimensions; i++)
//       {
//           centroids[*c][i] /= nPatternsCluster[*c];
//           //std::cout << "centroid: " << centroids[*c][i] << std::endl;
//       }
//   }
//       
//   return centroids;
//}


