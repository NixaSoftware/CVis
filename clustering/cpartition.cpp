// Class automatically generated by Dev-C++ New Class wizard

#include "cpartition.h" // class's header file


using namespace std;

cpartition::cpartition()
{
    patterns.clear();
    clustersLabels.clear();
}

cpartition::cpartition(fs::path fileName) 
{
    loadPartition(fileName);
}

// class destructor
//partition::~partition()
//{
//    
//	// insert your code here
//}

cpartition::cpartition(const cpartition &part)
{
    patterns = part.patterns;
    clustersLabels = part.clustersLabels;
    current = part.current;
}

cpartition & cpartition::operator = (const cpartition &part)
{
    patterns = part.patterns;
    clustersLabels = part.clustersLabels;
    current = part.current;
}

int cpartition::nPatterns()
{
    return patterns.size();
}

int cpartition::nClusters()
{
    return clustersLabels.size();
}

cpartition::t_iterator_Patterns cpartition::currentPattern()
{
    return current;
}

cpartition::t_iterator_Patterns cpartition::first()
{
    
    return patterns.begin();
}

cpartition::t_iterator_Patterns cpartition::last()
{
    return patterns.end();
}

cpartition::t_iterator_Patterns cpartition::find(string key)
{
    return patterns.find(key);
    
}

int cpartition::loadPartition(fs::path fileName)
{
    string id;
    int cluster;
    int i, n;
    t_Pattern pattern;
    int c = 0;
    map <int, int> clusterCorrespondence;
    map <int, int>::iterator ccIterator;
    
    fs::ifstream file;

    patterns.clear();
    clustersLabels.clear();

    file.open(fileName);
    if (!file.good()) 
    {
        std::cout << "\nError in the file '" << fileName.string() << "'\n";
        getchar();
        return -1;
    }
    
    while (!file.eof())
    {
        file >> id >> cluster;
        if (!file.fail())
        {
            ccIterator = clusterCorrespondence.find(cluster);
            if (ccIterator == clusterCorrespondence.end())
            {
                c++;
                clusterCorrespondence[cluster] = c;
            }
            patterns[id] = clusterCorrespondence[cluster];
            clustersLabels.insert(clusterCorrespondence[cluster]);
        }      
    }

   file.close();

   current = patterns.begin(); // current points to the first element
  
   return 0;

}

// Print the clustering in the file <fileName>
int cpartition::printPartition(fs::path fileName)
{
    int cluster;
    int i, n;
    map<const string, int, cmp>::iterator currentPattern;
    t_Pattern pattern;

    fs::ofstream file;

    file.open(fileName);
    if (file.bad()) 
    {
        std::cout << "\nCannot open file '" << fileName.string() << "'\n";
        getchar();
        return 1;
    }
    
    for (currentPattern = patterns.begin(); 
        currentPattern != patterns.end(); 
        currentPattern++)    
   {
      file << (*currentPattern).first << "\t" << (*currentPattern).second << std::endl;
   }

   file.close();
}

// show the clustering in the standard output
int cpartition::printPartition()
{
    map<const string, int, cmp>::iterator currentPattern;
    
    for (currentPattern = patterns.begin(); 
        currentPattern != patterns.end(); 
        currentPattern++)    
   {
      std::cout << (*currentPattern).first << "\t" << (*currentPattern).second << std::endl;
   }
}

int cpartition::randomPartition(fs::path dataset, fs::path fileResult, int k)
{
    
    string id;
    int cluster;
    int i, n;
    t_Pattern pattern;
    int c = 0;
    map <int, int> clusterCorrespondence;
    map <int, int>::iterator ccIterator;

    fs::ifstream file;
    
    patterns.clear();
    clustersLabels.clear();
  
    file.open(dataset);
    if (file.bad()) 
    {
        std::cout << "\nError in the file '" << dataset.string() << "'\n";
        getchar();
        return -1;
    }
    
    file.ignore(maxFileLine, '\n');
    while (!file.eof())
    {
        file >> id;
        file.ignore(maxFileLine, '\n');
        if (!file.fail())
        {
            cluster = rand() % k + 1; // numero entre 1 e k
            ccIterator = clusterCorrespondence.find(cluster);
            if (ccIterator == clusterCorrespondence.end())
            {
                c++;
                clusterCorrespondence[cluster] = c;
            }
            patterns[id] = clusterCorrespondence[cluster];
            clustersLabels.insert(clusterCorrespondence[cluster]);
        }      
    }
    
   file.close();

   current = patterns.begin(); // current points to the first element
   
   printPartition(fileResult);
   
   return 0;

}

set<int> cpartition::getClustersLabels()
{
    return clustersLabels;
}
    
cpartition::t_Patterns cpartition::getClustersPatterns()
{
    return patterns;
}
           
void cpartition::patternInsert(std::string pat, int cluster)
{     
    patterns[pat] = cluster;  
    clustersLabels.insert(cluster); 
}
 
