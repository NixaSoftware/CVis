// Class automatically generated by Dev-C++ New Class wizard

#ifndef SNN_H
#define SNN_H

#include <string>
#include <vector>
#include "cpartition.h"
#include "clusteringTypes.h"
#include "boost/tokenizer.hpp"
#include "boost/lexical_cast.hpp"

#include <iostream>



// object function that run the SOTA algorithm
class snn
{
	public:
        //typedef std::map<int, std::vector<double> > t_cells;
        // class constructor
		snn(std::string datasetName, std::string fileResultName, t_similarities sim,
            int NN, float strong, float topic, float noise, float merge, float label);
		snn(std::string datasetName, std::string fileResultName, t_similarities sim);
        snn();
		snn(std::string datasetName, std::string fileResultName, t_similarities sim, std::string parameters);
        snn(std::string parameters);
		// class destructor
		//~snn();
		snn(const snn &a);
		snn & operator = (const snn &a);

		cpartition run();
		void changeDataset(std::string datasetName);
		void changeResultFile(std::string fileResultName);
		void changeSimilarity(t_similarities sim);
        void changeNN(int value); 
        void changeStrong(float value); 
        void changeTopic(float value); 
        void changeNoise(float value);
        void changeMerge(float value);
        void changeLabel(float value); 
		cpartition getPartition();
		//t_cells getCells();

	private:
        std::string dataset;
        std::string fileResult;
        t_similarities similarity;     // 0 - dot product
                                       // 1 - cosine measure
                                       // 2 - jaccard coefficient (binary)
                                       // 3 - euclidean distance
                                       // 4 - correlation coefficient (dense format only)

        int NN; // near neighbor list size. this value should in general be small compared to the data size. (e.g. 50,100...)
        float strong; // Percentage of weak links [0,1].
                      // In order to determine representative points from the data, for every data point, the number of non-weak links are counted.  Higher the count, 
                      // higher the chances are that the point represents its neighborhood.
                      // Reasonable range: 0 - 0.4
        float topic; // Percentage of representative points [0,1].
                     // The points that have the highest strong link count will be selected as representatives.
                      // Reasonable range: 0.01 - 0.4
        float noise; // Percentage of noise in the data.
                      // Reasonable range: depends on the expected noise in the data
        float merge; // The percentage of links to be used in merging clusters.  This is very similar to the cut-off threshold in the single-link approach (the 
                     // strength of the weakest link to be used in merging). 
                      // Reasonable range: 0.05 - 0.3
        float label; // Specifies a weaker merge threshold that will not merge two clusters but will label points that are not clustered to the closest clusters if 
                     // their similarity is greater than 'merge_threshold*label'
                      // Reasonable range: 0 - 1 (labeling is off by default. specifying 0 will label every point that has a link to a clustered point)
        cpartition p;
    
        // default value from the original program
        static const int NNDefault = 20;
        static const float strongDefault = 0.25;        // # of weak links / total # of links
        static const float topicDefault = 0.10;  // # of topics     / total # of points
        static const float noiseDefault = 0.20;  // percentage of noise points
        static const float mergeDefault = 0.10;  // percentage of links to be used for merging
        static const float labelDefault = 1000;  // label*merge threshold=label threshold ... no labeling by default
};

        
#endif // SNN_H

